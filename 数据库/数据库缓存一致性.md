### 相关资料
```
[缓存更新的套路] https://coolshell.cn/articles/17416.html
[延时双删实现MySQL和Redis的数据一致性] https://cloud.tencent.com/developer/news/634004
[分布式之数据库和缓存双写一致性方案解析] https://www.cnblogs.com/rjzheng/p/9041659.html?spm=a2c6h.12873639.0.0.2020fe8dmDAMAu
```

### 缓存过期
```
从理论上说，只要我们设置了缓存的过期时间，我们就能保证缓存和数据库的数据最终是一致的
```

### 更新策略
```
注意：以下策略不依赖于"缓存过期"这个方案

(1) 先更新数据库，再更新缓存
    直接pass

(2) 先删除缓存，再更新数据库
    不一致情形：同时有一个请求A进行更新操作，另一个请求B进行查询操作
    1) 请求A进行写操作，删除缓存
    2) 请求B查询发现缓存不存在
    3) 请求B去数据库查询得到旧值
    4) 请求B将旧值写入缓存
    5) 请求A将新值写入数据库

    解决方案：延时双删策略

(3) 先更新数据库，再删除缓存
    不一致情形：一个请求A做查询操作，一个请求B做更新操作
    1) 缓存刚好失效
    2) 请求A查询数据库，得一个旧值
    3) 请求B将新值写入数据库
    4) 请求B删除缓存
    5) 请求A将查到的旧值写入缓存
    上述情况存在的概率不大，因为读操作一般会快于写操作，就是A的操作快于B
    为了确保万无一失，可以采用"延时双删除策略"


上述2、3会存在删除失败的情况，解决方案是用"删除重试策略"

```

### 延时双删除
```
不同的更新策略，延时双删不同

(1) 先删除缓存，再更新数据库
    redis.Del("key")
    db.Update("key", "value")
    thread.Sleep(1s)
    redis.Del("key")

(2) 先更新数据库，再删除缓存
    db.Update("key", "value")
    redis.Del("key")
    thread.Sleep(1s)
    redis.Del("key")
```

### 删除重试策略
```
(1) 方案一
    1) 更新数据库数据
    2) 缓存因为种种问题删除失败
    3) 将需要删除的key发送至消息队列
    4) 自己消费消息，获得需要删除的key
    5) 继续重试删除操作，直到成功
    该方案有一个缺点，对业务线代码造成大量的侵入

(2) 方案二
    1) 更新数据库数据
    2) 数据库会将操作信息写入binlog日志当中
    3) 订阅程序提取出所需要的数据以及key
    4) 另起一段非业务代码，获得该信息
    5) 尝试删除缓存操作，发现删除失败
    6) 将这些信息发送至消息队列
    7) 重新从消息队列中获得该数据，重试操作
    上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能
```