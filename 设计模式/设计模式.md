### 资料
```
https://design-patterns.readthedocs.io/zh_CN/latest/
https://refactoringguru.cn/design-patterns/builder
```

### 类之间的关系
```
1、泛化关系(generalization)
    类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：

    继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)

    // 自行车是车、猫是动物
    // 汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；

    最终代码中，泛化关系表现为'继承非抽象类'

2、实现关系(realize)
    // 车为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）

    最终代码中，实现关系表现为'继承抽象类'

3、聚合关系(aggregation)
    > 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义(组成关系)
    > 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在

    // 例如一个部门由多个员工组成
    // 例如部门撤销了，人员不会消失，他们依然存在

4、组合关系(composition)
    > 与聚合关系一样，组合关系同样表示整体由部分构成的语义
    > 组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了

    // 比如公司由多个部门组成
    // 例如公司不存在了，部门也将不存在了

5、关联关系(association)
    > 它描述'不同类的对象之间'的结构关系
    > 它是一种静态关系
    > 关联关系是一种'强关联'的关系
    > 关联关系默认不强调方向，例如A知道B，但B不知道A
    
    // 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系

    在最终代码中，关联对象通常是以成员变量的形式实现的

6、依赖关系(dependency)
    > 他描述一个对象在运行期间会用到另一个对象的关系
    > 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化
    > 依赖也有方向，双向依赖是一种非常糟糕的结构，总是应该保持单向依赖，杜绝双向依赖的产生

    在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系
    依赖关系除了临时知道对方外，还是'使用'对方的方法和属性
```

### 创建型模式
```
创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离

创建型模式隐藏了类的实例的创建细节，只提供共同的接口

1、简单工厂模式
    (1) 定义
        又称为静态工厂方法模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例
        简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
    (2) 结构
        1) Factory
            工厂角色
            工厂角色负责实现创建所有实例的内部逻辑
        2) Product
            抽象产品角色
            抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
        3) ConcreteProduct
            具体产品角色
            具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例
    (3) 代码展示
        // Product 抽象产品角色
        class Product {
            Product(){}
            virtual ~Product(){}
            virtual void use() = 0;
        };

        // ConcreteProduct 具体产品角色
        class ConcreteProduce1 : public Produce {
            void use() {}
        };
        class ConcreteProduce2 : public Produce {
            void use() {}
        };

        // Factory 工厂角色
        Product* createProduct(string name) {
            switch (name) {
                case "1":
                    return new ConcreteProduce1();
                case "2":
                    return new ConcreteProduce2();
            }
        }
    (4) 特点
        1) 要点
            当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节
        2) 优点
            在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责
        3) 缺点
            在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂
        4) 适用情况
            工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心

2、工厂方法模式
    (1) 定义
        也叫虚拟构造器模式或者多态工厂模式，它属于类创建型模式
        在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类
    (2) 结构
        1) Product
            抽象产品
        2) ConcreteProduct
            具体产品
        3) Factory
            抽象工厂
        4) ConcreteFactory
            具体工厂

        工厂        产品
        抽象工厂    抽象产品
        具体工厂    具体产品

    (3) 代码展示
        某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等
        且用户可以根据要求动态选择日志记录方式，现使用工厂方法模式设计该系统
        
        class LogFactory;
        class Log;

        // 抽象工厂
        class LogFactory {
            LogFactory(){}
            virtual ~LogFactory(){}
            virtual Log* createLog() = 0;
        };

        // 具体工厂
        // 实现文件日志Factory
        class FileLogFactory : public LogFactory {
            Log* createLog() {
                return new FileLog();
            }
        };
        // 实现数据库日志Factory
        class DatabaseLogFactory : public LogFactory {
            Log* createLog() {
                return new DatabaseLog();
            }
        };

        // 抽象产品
        class Log {
            Log(){}
            virtual ~Log(){}
            virtual void writeLog() = 0;
        };

        // 具体产品
        // 实现文件日志产品
        class FileLog : public Log{
            void writeLog() {}
        };
        // 实现数据库日志产品
        class DatabaseLog : public Log{
            void writeLog() {}
        };
    
    (4) 特点


3、抽象工厂模式
    (1) 定义
        在工厂方法模式下，每一个具体工厂对应一种具体产品，但是我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象
        提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

    (2) 结构
        1) AbstractFactory
            抽象工厂
        2) ConcreteFactory
            多个具体工厂
            ConcreteFactory1, ConcreteFactory2
        3) AbstractProduct
            多个抽象产品
            AbstractProduct1, AbstractProduct2
        4) Product
            多个具体产品
            Product11, Product12
            Product21, Product22
    (3) 代码实现
        // 抽象工厂
        class Factory {
            Factory(){}
            virtual ~Factory(){}
            virtual ProductA* createProductA() = 0;
            virtual ProductB* createProductA() = 0;
        };
        // 具体工厂
        class Factory1 : public Factory {
            ProductA* createProductA() {
                return new ProductA1();
            }
            ProductB* createProductB() {
                return new ProductB1();
            }
        };
        class Factory2 : public Factory {
            ProductA* createProductA() {
                return new ProductA2();
            }
            ProductB* createProductB() {
                return new ProductB2();
            }
        };

        // 抽象产品
        class ProductA {
            ProductA(){}
            virtual ~ProductA(){}
            virtual void use() = 0;
        };
        class ProductB {
            ProductB(){}
            virtual ~ProductB(){}
            virtual void eat() = 0;
        };

        // 具体产品
        class ProductA1 : public ProductA {
            void use(){}
        };
        class ProductA2 : public ProductA {
            void use(){}
        };

        class ProductB1 : public ProductB {
            void eat(){}
        };
        class ProductB2 : public ProductB {
            void eat(){}
        };

4、建造者模式(生成器模式)
    (1) 定义
        对于大型复杂对象，其内部包含很多对象成员，构造这个复杂对象会涉及内部属性限制条件、先后顺序等
        将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

    (2) 结构
        1) Builder
            抽象建造者
        2) ConcreteBuilder
            具体建造者
        3) Director
            指挥者
            使用Builder接口创建一个完整产品对象，它负责管理正确的对象创建顺序，从参数中接受具体的ConcreteBuilder对象
        4) Product
            产品角色
            Director.construct返回的结构

        ConcreteBuilder * builder = new ConcreteBuilder();
        Director  director;
        director.setBuilder(builder);
        Product * pd =  director.constuct();

    (3) 代码表示
        // 抽象构造着
        class Builder {
            Builder(){}
            virtual ~Builder(){}
            virtual void reset() = 0;
            virtual void buildPartA() = 0;
            virtual void buildPartB() = 0;
            virtual void buildPartC() = 0;
            virtual Product* getResult() = 0;
        };

        // 具体构造着
        class ConcreteBuilder : public Builder {
            Product* result;
            void reset() {
                result = new Product();
            }
            void buildPartA(int) {}
            void buildPartB(int) {}
            void buildPartC(int) {}
            Product* getResult() {
                return result;
            }
        }

        // 指挥者
        class Director {
            Builder* builder;
            void setBuilder(Builder* _builder){
                builder = _builder;
            }
            Product* construct(){
                builder->reset();
                // 此处可根据不同参数、条件、顺序等来组合构造条件
                builder->buildPartA(1);
                builder->buildPartB(2);
                builder->buildPartC(3);
                return builder->getResult();
            }
        }

        // 使用方式
        ConcreteBuilder* builder = new ConcreteBuilder();
        Director director;
        director.setBuilder(builder);
        Product* res = director.construct();

5、单例模式
    (1) 定义
        单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法
        一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例
    (2) 结构
        Singleton
            单例
    (3) 代码表述
        // 全局唯一类
        class Singleton {
            
            Singleton(){}
            virtual ~Singleton(){
                if (singleton) delete singleton;
            }
            static Singleton* getInstance();
            void doSomething(){}
        private:
            static Singleton* singleton;
        };

        Singleton* Singleton::singleton = NULL;

        void Singleton::getInstance(){
            if (singleton == NULL) {
                singleton = new Singleton();
            }
            return singleton;
        }

        // 使用
        Singleton* single = Singleton::getInstance();
        single->doSomething();
```


### 结构型模式
```
1、适配器模式
    (1) 定义
        将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)
    (2) 结构
        Target
            目标抽象类
        Adapter
            适配器类
        Adaptee
            适配者类
        Client
            客户类
    (3) 代码实现
        // 目标抽象类
        class Target {
            virtual void request() = 0;
        };

        // 适配器类
        class Adapter : public Target{
            Adapter(Adaptee* adaptee_) {
                adaptee = adaptee_;
            }

            virtual ~Adapter(){}

            virtual void request() {
                adaptee->specificRequest();
            }
        private:
            Adaptee* adaptee;
        }

        // 适配者类
        class Adaptee {
            void specificRequest();
        }

        // 使用
        Adaptee *adaptee = new Adaptee();
        Target *tar = new Target(adaptee);
        tar->request();

2、桥接模式
    (1) 定义
        将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式

    (2) 结构
        Abstraction
            抽象类
        RefinedAbstraction
            扩充抽象类
        Implementor
            实现类接口
        ConcreteImplementor
            具体实现类
        // 例如
          (Abstraction)          (Implementor)
               形状 ---------------> 颜色
                |        包含         |  
           +----+----+          +-----+-----+
           |         |          |           |
          圆形      方形        黄色        绿色
        (RefinedAbstraction)  (ConcreteImplementor)

    (3) 代码展示
        https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180712208-505786819.png

3、装饰模式！！！
    (1) 定义
        装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同
        动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合
    (2) 结构
        Component
            抽象构件
        ConcreteComponent
            具体构件
        Decorator
            抽象装饰类
        ConcreteDecorator
            具体装饰类
    (3) 代码表述
        // 例如：给手机贴膜、装手机壳、装挂件

        // 抽象构建
        class Component {
        public:
            virtual void operation() = 0;
        };

        // 具体构建
        class Phone : public Component {
        public:
            void operation() {
                cout << "手机" << endl;
            }
        };

        // 抽象装饰类
        class Decorator : public Component {
        public:
            Decorator(Component* comp):component(comp){}
            void operation() {
                component->operation();
            }
        private:
            Component* component;
        };

        // 具体装饰类
        // 贴膜
        class DecoratorSticker : public Decorator {
        public:
            DecoratorSticker(Component* comp):Decorator(comp){}
            void operation() {
                Decorator::operation();
                cout << "贴膜" << endl;
            }
        };
        // 装壳
        class DecoratorShell : public Decorator {
        public:
            DecoratorShell(Component* comp):Decorator(comp){}
            void operation() {
                Decorator::operation();
                cout << "装壳" << endl;
            }
        };
        // 挂绳
        class DecoratorRope : public Decorator {
        public:
            DecoratorRope(Component* comp):Decorator(comp){}
            void operation() {
                Decorator::operation();
                cout << "挂绳" << endl;
            }
        };

        // 用法
        Component *c = new Phone();
        Component *c1 = new DecoratorSticker(c);
        Component *c2 = new DecoratorSticker(c1);
        Component *c3 = new DecoratorSticker(c2);
        c3->operation();
```

