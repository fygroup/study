
### lisp
```
先学习lisp的思想，对编译原理有很大的帮助
```

### FA
```
FA(有限自动机)是个五元组 M = (S, ∑, δ, S0, Z)
S   识别器中的有限状态机，以及一个错误状态
∑   识别器中使用的有限字母表
δ   δ(s, c)是识别器转移函数，它将每个状态s∈S和每个字符c∈∑的组合(s, c)映射到下个状态，即s->δ(s, c)
S0  起始状态
Z   接受(终止)状态的集合，Z∈S，Z中的每个状态在转移途中用双层圆圈表示

```

### 从 RE 到 DFA
```
RE(正则表达式)
DFA(确定性FA)
NFA(非确定性FA)


    Thompson构造法        子集构造法
RE ---------------> NFA -----------> DFA ----->词法分析器代码
                                     ↑ ↓                                    
                                     +-+  
                                  DFA最小化

     Kleene
DFA ----------> RE


1、Thompson
    > 构造每个字符的NFA
    > 每个NFA都有一个起始状态和一个接收状态
    > 使用ϵ转移来连接前一个NFA的接受状态和后一个NFA的起始状态
    > 每个状态至多有两个进入该状态和两个退出该状态的ϵ转移

2、子集构造法
    https://www.jianshu.com/p/de84d27264cc
    https://www.cnblogs.com/Zzzcode/p/10843983.html
    https://zhuanlan.zhihu.com/p/37900383

    ε - closure(s)  能够从NFA状态s开始只通过ε转换到达的NFA状态集合
    ε - closure(T)  能够从T中某个NFA状态s开始只通过ε转换到达的NFA状态集合，即 ⋃(s∈T) | ε - closure(s)
    move(T, a)      能够从T中某个状态s出发通过标号为a的转换到达的NFA状态的集合
    
    // 算法描述
    n0 起始状态
    q0 <- ε - closure({n0})
    Q <- q0
    worklist <- {q0}
    while (worklist ≠ NULL) do
        remove q from worklist
        foreach (c ∈ ∑) do
            t <- ε - closure(move(q, c))
            T[q, c] <- t                    // T是一个迭代矩阵
            if (t not in Q) then
                Q <- q
                worklist <- q
        end;
    end;


3、DFA最小化
    将DFA中的状态分为终态(接收态)和非终态(非接收态)
    > 多余状态需要删除
        一个非终态无法到达终态
        一个终态其任何非终态都无法到达它
    > 等价状态(不可分)和非等价状态(可分)

    // 算法描述
    DFA = {D, ∑, δ, d0, DA} // D是上述第二步得到的状态集合；DA是接受状态集合
    T <- {DA, {D-DA}}       // 将D分为DA(接收态集合)和D-DA(非接收态集合)
    P <- {}
    while (P ≠ T) do
        P <- T
        T <- {}
        foreach (p ∈ P) do
            T <- T ∪ split(p)
        end
    end

    split (S) {
        foreach (c ∈ ∑) do
            if (c split S into {s1, s2}) then
                return {s1, s2}
        end
        return S
    }
```

### DFA如何识别单词
```
重复读取输入的下个字符，用DFA根据输入的字符进行状态转移，当字符输入完毕，判断当前状态S
如果S是接收态，则向调用者成功返回词素及语法范畴
如果S是非接收态，如果词法分析中遇到过接收态，则需要回溯，并报告成功；如果没有，则报告失败
```
