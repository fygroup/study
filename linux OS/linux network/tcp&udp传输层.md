# 概述
## 封装
[数据进入协议栈时的封装过程](../picture/10.png)
## 客户端-服务器模型
服务分为两种类型：重复型或并发型。
一般来说， T C P服务器是并发的，而U D P服务器是重复的，但也存在一些例外
## 端口号
大多数Unix系统的文件/etc/services都包含了人们熟知的端口号
## 应用编程接口
TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI

# 链路层
## 链路层目的
```
（1）为IP模块发送和接收IP数据报；
（2）为ARP模块发送ARP请求和接收ARP应答；
（3）为RARP发送RARP请求和接收RARP应答。
TCP/IP支持多种不同的链路层协议取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路
```

## 以太网链路层协议（多个连接在一起）
```
以太网和IEEE 802封装
1、以太网
是当今TCP/IP采用的主要的局域网技术，速率为10Mb/s，地址为48bit，
2、IEEE 802
802.3针对整个CSMA/CD网络，802.4针对令牌总线网络， 802.5针对令牌环网络
[IEEE 802.2/802.3（RFC 1042）和以太网的封装格式（RFC 894）](../picture/11.png)
```

## 两个串行接口链路层协议（点对点连接，所以没有以太网的头部）
```
（1）SLIP和CSLIP
（2）PPP
点对点链路链接不用ARP协议
```

## 环回接口
```
允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信，P地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。
[环回接口处理IP数据报的过程](../picture/12.png)
```

## 以太网帧
```
| Mac首部 | IP首部 | TCP首部 | HTTP首部 | HTML数据 |
<------------------以太网帧----------------------->
          <--------------以太网帧的净荷------------>
                  <---------ip净荷---------------->
                        <--------tcp净荷---------->
```

## MTU
```
最大传输单元，MTU是数据链路层的概念
数据链路不同，最大传输单元也不同，由于IP协议是数据链路的上一层，所以它必须不受数据链路的MTU大小的影响能够加以利用。当IP数据报太大时，就要采用分片技术，以保证数据帧不大于要过的网络的MTU。
```

# IP协议
## IP首部
```
+--------+-------------+-------------+-------------------------+
| 4位版本 | 4位首部长度 | 8位服务类型  |      16位总长度          |
+--------+-------------+-------------+----------+--------------+
|              16位标识符             |  3位标志 |  13位片偏移   |
+------------------------------------+----------+--------------+
|   8位生存时间(TTL) 8位协议          |     16位首部检验和        |
+------------------------------------+ ------------------------+
|                          32位源ip地址                         |
+--------------------------------------------------------------+
|                         32位目的ip地址                        |
+--------------------------------------------------------------+
|                          选项（如果有）                       |
+--------------------------------------------------------------+
|                              数据                            |
+--------------------------------------------------------------+

> 4位版本号：IPv4
> 首部长度：首部占32bit字的数目,例如5表示5*32=20byte（所以首部肯定为32的整数倍）
> 8位服务类型（TOS）:包括一个3bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1bit未用位但必须置0,4bit中只能置其中1bit。如果所有4 bit均为0，那么就意味着是一般服务。4bit分别代表最小时延、最大吞吐量、最高可靠性和最小费用
> 16位总长度，整个IP数据报的长度，以字节为单位，最长可达65535字节，但是大多数的链路层都会对它进行分片
> 16位标识，每发送一份报文它的值就会加1
> 3位标识，13位片偏移
> 8位生存时间（TTL）,一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃
> 8位协议，指的是TCP、UDP、ICMP、IGMP
> 16位首部检验和，首部每个16位进行反码求和，结果存在检验和字段中。当收到ip数据报时，对首部每个16位进行反码求和（包含了检验和字段），结果应该为1（由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算）
> 32位源ip地址
> 32位目的ip地址
> 附加项字段，路径路由ip等


```

## IP路由选择
```
IP层在内存中有一个路由表，当收到一份数据报时，先检查ip是否为本机ip地址之一或广播地址，
如果是按照ip首部制指定的协议进行处理，不是就进行转发（路由选择）
路由表包含：
（1）目标IP地址：完整的主机地址或者一个网络地址
（2）下一站路由IP地址：
（3）标志：目的ip是网络还是主机地址
路由选择：
（1）能与目的IP完全匹配的表目，发送指定的下一站路由或网路接口
（2）能与目的IP网络号匹配的表目，发送指定的下一站路由或网路接口
（3）发送默认表目
```

## 静态选路
```
3种方法生成路由表：
> 系统默认的方式生成路由表项
> 通过route来增加表项
> 通过ICMP报文来更新表项
     当IP包在某一个地方转向的时候，都回给发送IP报的源主机一个ICMP重定向报文，而源主机就可以利用这个信息来更新自己的路由表，这样，随着网络通信的逐渐增多，路由表也就越来越完备，数据转发的速度也会越来越快。我们需要注意的是：重定向报文只能由路由器发出；重定向报文为主机所用，而不是为路由器所用。
```

## 动态选路
```
当上面3种方式不能用时，就使用动态选路协议。注意：动态选路不会改变IP层的选路方式。仅仅改变路由表的信息（随时间的变化，路由守护程序会动态的更新路由表信息）
```

## 子网寻址（子网掩码）
```
//结构
     网络号    子网号    主机号

//子网掩码
     作用是多少比特用于子网号及多少比特用于主机号

//在主机上设置子网掩码的作用只有一个，就是判断将要连接的ip地址和主机是否处于一个子网，如果是，则只经过数据链路层，直接发送到ip地址，而不经过路由，否则将数据包发送到路由。

//掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。
两种不同类型
B类:11111111 11111111 11111111    00000000
         网络号16位     子网号      主机号
    11111111 11111111 11111111 11 000000
         网络号16位     子网号      主机号
```

## 相关命令
```
//ipconfig

//netstat
     提供系统上的接口信息
```



## ARP和RARP协议
1、ARP
```
//概念
     ARP协议是地址解析协议（Address Resolution Protocol）是通过解析IP地址得到MAC地址的，是一个在网络协议包中极其重要的网络传输协议，它与网卡有着极其密切的关系

     通常网卡仅接收目的地址为网卡物理地址或广播地址的帧

     ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播。目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了

//命令
     检查arp高速缓存中Ip地址到硬件地址之间的映射记录：arp -a

//交换机与路由器
     交换机主要工作在数据链路层（第二层），交换机转发所依据的对象时：MAC地址。（物理地址）
     路由器工作在网络层（第三层）。路由转发所依据的对象是：IP地址。（网络地址）
     所以需要ARP协议，需要目的IP地址的MAC地址

//发送过程
     我的电脑 ------------> 网关 -------------> 服务器
               网关的MAC          服务器的MAC
     注意：点对点链路不涉及ARP协议

//免费ARP
     一种ARP特性，它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候     
     主要用于检测网络中IP地址是否冲突，它是一种功能而非协议。向自己所在网络请求自己的MAC地址，当网络中如果有其他主机使用了与自己相同的IP地址，他就会给主机一个ARP回复，此时如果发免费ARP的主机收到了回复就证明自己所用的IP地址有冲突，如果没有收到回复则说明没有IP地址冲突。

```

2、RARP
```
//概念
     ARP是实现IP到MAC地址的映射，而RARP是实现MAC到IP地址的映射。

```

## UDP
```
1、首部
     +------------------------------------------------------------+----------
     |                         32位源IP地址                        |
     +------------------------------------------------------------+ 
     |                         32位目标IP地址                      | UDP伪首部 
     +---+-------------------------+------------------------------+
     | 0 |        8位协议(17)       |          16位UDP长度         |
     +---+-------------------------+------------------------------+----------
     |        16位源端口号          |         16位目标端口号        |
     +-----------------------------+------------------------------+ UDP首部
     |         16位UDP长度          |         16位UDP检验和        |
     +-----------------------------+------------------------------+----------
     |                            数据                            |
     +                  +-----------------------------------------+
     |                  |              填充字节                    |  
     +------------------+-----------------------------------------+
     
     UDP伪首部：和TCP段都包含一个12字节长的伪首部，为了为了计算检验和而设置的。其目的是让UDP两次检查数据是否已经正确到达目的地（例如， IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）
     UDP首部

2、UDP检验
     UDP检验和覆盖UDP首部和UDP数据
     检验方法与ip类似（16 bit字的二进制反码和）。因为UDP数据报的长度可以为奇数字节，在最后增加填充字节0
     发送方先对UDP检验和的16位全至为0，然后对其进行反码求和，结果写道UDP检验和处。接收方以16位为单位对所有进行加和，结果应为0XFFFF，如果有错就直接丢弃，不报错

3、分片
     UDP层没有分片机制，UDP传递的是数据包，应用层给的数据，会直接发送，需要应用层自己去控制
     任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片
     IP层本身没有超时重传的机制，丢失一片数据也要重传整个数据包

```

### TCP
```
1、TCP首部
     https://coolshell.cn/articles/11564.html

     +----------------------------------------------------------+--------------------------------------------------+
     |                          16位源端口号                     |                  16位目的端口号                   |
     +----------------------------------------------------------+--------------------------------------------------+
     |                                                      32位序列号                                              |
     +-------------------------------------------------------------------------------------------------------------+
     |                                                     32位确认序号                                             |
     +------------+---------+-----+-----+------+-----+-----+------+------------------------------------------------+
     | 4位首部长度 | 保留6位 | URG | ACK | PSH  | RST | SYN |  FIN  |          16位窗口大小 WIN（最大65535字节）       |
     +------------+---------+-----+-----+------+-----+-----+------+------------------------------------------------+
     |                           16位检验和                        |                  16位紧急指针                   |
     +------------------------------------------------------------+------------------------------------------------+
     |                                                        选项                                                 |
     +-------------------------------------------------------------------------------------------------------------+
     |                                                        数据                                                 |
     +-------------------------------------------------------------------------------------------------------------+
     TCP首部不计任选字段，它通常是20个字节。

     URG 表示紧急指针有效
     ACK 确认序号有效
     PSH 接收方应该尽快将这个报文段交给应用层
     RST 复位标志
     SYN 同步序号用来发起一个连接
     FIN 发端完成发送任务
     紧急指针 是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号
     最常见的可选字段是最长报文大小，又称为MSS (Maximum Segment Size)

2、TCP如何来保持可靠性
     (1) TCP传递的是字节流，应用数据被分割成合适的块（报文段）
     (2) 当TCP发出一个报文段后，会启动一个定时器。如果不能及时收到确认，就会重新发送这个报文段
     (3) 收到数据后需要进行确认，但不是立即发送(时延的确认)
     (4) 保持首部和数据的检验和，检验错误会重发
     (5) TCP收到的数据会进行排序
     (6) TCP接收端会丢掉重复发送的数据
     (7) TCP提供流量控制(滑动窗口协议)

     确认和超时重传、合理分片和排序、流量控制、拥塞控制、数据校验

```

### TCP的连接与终止
```
1、tcpdump抓包工具
     //返回结果
     16:08:33.130225 IP localhost.ssh > localhost.51708: Flags [P.], seq 240368:240912, ack 3361, win 1578, length 544, mss 1024
     时间               源地址           目的地址          标志                           
     1) flag
          标识 3字符缩写 描述
          S    SYN      同步序号
          F    FIN      发送方完成数据发送
          R    RST      复位连接
          P    PSH      尽可能快地将数据送往接收进程
          .             以上四个标志比特均置0
     2) seq 240368:240912
          表示分组序号是240368，报文段的字节数240912-240368=544
          Wireshark抓包程序会发现SeqNum总是为0，Wireshark为了显示更友好，使用了相对序号
     3) ack 3361
          确认序号，只有首部ACK表示被设置成1才显示
     4) win 1578
          表示发端通告窗口大小
     5) 数据字节数
          544，就是上面序列号相减
     6) mss 1024
          发端最大报文长度，表示发端不接受超过这个长度的报文段
          TCP在建立连接的时候，会协商双方的MSS值，通常这个MSS会控制在MTU以内：最大IP包大小减去IP和TCP协议头的大小（其最终目的：就是尽量避免IP分片）

2、连接与终止协议
     (1) 连接协议(3次握手)
          1) 客户端发送一个SYN打算连接的服务器的端口，以及初始序号(1415531521)
          2) 服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将客户端的序号+1以对客户的SYN报文段进行确认
          3) 客户端将服务端的序号+1以对服务端的SYN报文段进行确认
          注意：初始序号ISN随时间而变化，因此每个连接都将具有不同的ISN
          client                                       server
                         SYN seq=x
          connect ------------------------------------>  
                    SYN seq=y, ACK=x+1
               <------------------------------------ listen
                         ACK=y+1
               ------------------------------------>

     (2) 传输过程
          client                                       server
                         SYN seq=x+1, ACK=y+1
          write  ------------------------------------>  
                              ACK=x+2
               <------------------------------------ read

     (3) 终止连接(4次握手)
          client                                       server
                         FIN seq=x+2, ACK=y+1
          close  ------------------------------------>  
                         ACK=x+3
               <------------------------------------ 
                         FIN seq=y+1, ACK=x+3
               <------------------------------------ close
                         ACK=y+2
               ------------------------------------>
3、TCP状态迁移
     client状态                                           server状态
                                                          socket、bind、listen
                                                          LISTEN(被动打开) 
                                                          accept(阻塞)
     connect(阻塞)       ---------SYN j--------->        
     SYN_SEND                                             SYN_RCVD
                        <---SYN k, ACK j+1----- 
     ESTABLISHED
     connect(返回)       -------ACK k+1--------->             
                                                          ESTABLISHED                             
                                                          accept(返回)   
                                                          

     close()             --------FIN m--------->              
     FIN_WAIT_1                                           CLOSE_WAIT
                         <--------ACK m+1-------          read返回0
     FIN_WAIT_2
                         <--------FIN n---------          close()
                                                          LAST_ACK                    
                         --------ACK n+1------->          CLOSED       
     TIME_WAIT
         | 等待2MSL           
     CLOSED

4、SYN超时
     (1) 发生时机
          发生在TCP三次握手中
          如果server端接到了client发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败，处于'半连接'状态

     (2) 处理方式
          server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接

     (3) SYN Flood攻击
          发生在TCP三次握手中
          如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握手，会造成B分配的内存资源就一直这么耗着，直到资源耗尽
          恶意客户端发送大量的SYN后就断线了，于是服务器的syn连接的队列耗尽，让正常的连接请求不能处理

     (4) 应对方式
          1) 普通方法
               1> 提高TCP半开连接队列大小的上限
                    /proc/sys/net/ipv4/tcp_max_syn_backlog
               2> 减少半开状态下等待ACK消息的时间或者重试发送SYN-ACK消息的次数
                    /proc/sys/net/ipv4/tcp_synack_retries
               3> 在检测到监听backlog 队列已满时，直接发 RST 包给客户端终止此连接
                    /proc/sys/net/ipv4/tcp_abort_on_overflow
               上述办法会降低正常用户连接的成功率     
          2) 先进方法
               1> SYN Cache
                    1> 原理
                         构造一个全局的Hash Table，用来缓存系统当前所有的半开连接信息，连接成功则从Cache中清除相关信息
               2> SYN Cookies
                    1> 原理
                         与HTTP Cookies技术类似，server端不存储任何连接信息，而是把连接信息编码成cookies，随同SYN-ACK发给客户端
                         如果A是正常用户，则会向B发送最后一次握手消息（ACK），B收到后验证“Cookie”的内容并建立连接
                         如果A是攻击者，则不会向B反馈ACK消息，B也没任何损失，也就说是单纯的SYN攻击不会造成B的连接资源消耗
                    2> 缺点
                         server端不保存连接的半开状态，就丧失了重发SYN-ACK消息的能力

          所有这些方案都不完美各有利弊，最终的策略可能是几种方案的结合使用，形成防御体系，将攻击提前化解在局部，不至于影响整个系统

5、半关闭状态
     (1) 概念
          TCP提供连接的一端在结束它的发送后还能接受来自另一端的数据
          当TCP链接中A向B发送 FIN 请求关闭，另一端B回应ACK之后，并没有立即发送 FIN 给A,A方处于半连接状态（半开关），此时A可以接收B发送的数据，但是A已经不能再向B发送数据

     (2) 过程
          client                                        server
                              FIN
          shutdown         --------------------------> 向应用进程交付EOF       
                         <-------------------------
                              FIN的ACK

                              data
          应用进程read      <------------------------- 应用进程write
                         ------------------------->   
                              data的ACK

                              FIN
          向应用进程交付EOF <------------------------- 应用进程close
                         ------------------------->           
                              FIN的ACK

     (3) 为什么需要半关闭
          如果没有半关闭，需要其他的一些技术让客户通知服务器, 客户端已经完成了它的数据传送，但仍要接收来自服务器的数据。使用两个 T C P连接也可作为一个选择，但使用半关闭的单连接更好

     (4) close与shutdown
          1) close
               关闭本进程的sockfd
               如果多个进程共享这个套接字，一个进程关闭会导致描述符引用计数减一，直到引用计数等于零时，才会引发TCP的四路握手断连过程
          2) shutdown
               会切断进程共享的套接字的所有连接，不管这个套接字的引用计数是否为零，那些试图读得进程将会接收到EOF标识，那些试图写的进程将会检测到SIGPIPE信号
               用途：多进程，你想防止其他线程或进程访问到该资源，又或者你想立刻关闭这个socket，那么可以用shutdown()来实现，但是最后还是要调用close

          3) shutdown API
               #include <sys/socket.h>
               int shutdown(int sockfd, int how);
               // sockfd 需要关闭的socket的描述符
               // how    允许为shutdown操作选择以下几种方式:
                    SHUT_RD(0)     关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉
                    SHUT_WR(1)     关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作
                    SHUT_RDWR(2)   关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR

          4) close和shutdown的注意内容
               1) 只要TCP栈的读缓冲里还有未读取(read)数据，则调用close时会直接向对端发送RST
               2) 即使调用shutdown(fd, SHUT_RDWR)也不会关闭fd，最终还需close(fd)。
               3) 当有多个socket描述符指向同一socket对象时，调用close时首先会递减该对象的引用计数，计数为0时才会发送FIN包结束TCP连接。shutdown不同，只要以SHUT_WR/SHUT_RDWR方式调用即发送FIN包。

6、MSL和TIME_WAIT
     (1) MSL
          报文最大寿命时间，可为30s，1min或2min。注意区分ip的TTL。
     (2) TIME_WAIT
          也称2MSL等待状态，tcp四次挥手中主动关闭连接方(client)发送完最后一次挥手，从TIME_WAIT状态到CLOSED状态有一个超时设置，这个超时设置是2MSL
          TIME_WAIT过程中client(主动关闭方)不能再被使用此端口号，只有等到2MSL结束后才能被系统使用
          1) 为什么需要time_wait
               1> 客户端发往服务端的最后一个ack确认包可能会丢失
                    //正常情况
                    client            server
                         FIN m
                         ----------->
                         ACK m+1
                         <-----------
                         FIN n
                         <-----------
                         ACK n+1
                         ----------->   
                    当client发送完最后一次的ACK(n+1)报文段后立即关闭端口，由于网络原因ACK(n+1)报文段丢失，server会重传FIN(n)报文段，但是已经关闭连接的client认为这是一个非法报文段，返回给服务端RST数据包，导致server不能进入正常的CLOSED状态，耗费资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。
               2> 有足够的时间让这个连接不会跟后面的连接混在一起
                    有些自做主张的路由器会缓存IP数据包，当系统复用已经关闭的端口，可能会导致旧应用延迟收到的包与新的应用混在一起

7、RST复位报文段
     (1) 概念
          在TCP协议中RST比特表示复位，用来关闭异常的连接，在TCP的设计中它是不可或缺的
          对于RST报文段，另一端不需要发送任何响应，因为发送完RST报文后，这条tcp连接就关闭了，也就没有必要确认了，收到RST的一方将终止该连接，并通知应用层复位连接

     (2) 产生RST的原因
          (1) 端口不存在
          (2) 异常终止(主动)一个链接
               终止一个连接的正常方式是一方发送FIN
               但也有可能主动发送一个复位报文段而不是FIN来中途释放一个连接(需要注意的是RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到RST的一方将终止该连接，并通知应用层连接复位)
          (3) 检测半打开连接
               如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接状态称为半打开连接 (TCP的keepalive选项能使TCP的一端发现另一端已经消失)

8、同时打开、同时关闭
     迁移状态与普通的不一样


9、呼入连接请求队列
     当到达多个连接请求时，可能由于服务器正在处理其他进程，或服务进程正在处理其他事务，导致没法立即接收新的连接请求。TCP协议是如何处理这些呼入的连接请求？
     关键字：连接队列、缓冲队列
     (1) 服务端有一个固定长度的连接队列（应用层可以指定最大长度 0~5），该队列中的连接已被TCP接受（即三次握手已经完成），但还没有被应用层所接受。TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
     (2) 对于新的连接请求，如果连接队列中还有空间，则进行三次握手完成连接的建立。
     (3) 应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接时。客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了（如果发生这种情况，服务器的TCP仅将接收的数据放入缓冲队列)。
     (4) 如果对于新的连接请求，连接队列中已没有空间, TCP将不理会收到的SYN。也不发回任何报文段（即不发回R S T）。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。
```
<img src="../../picture/17.jpg" width="400px" height="600px" />

### TCP交互数据流
```
1、交互式输入
     client                        server
     按键   ----数据字节------>     接收字节，然后进行时延的确认推迟发送ACK
            <---数据字节确认---    
            <---回显数据字节---     回显     
     显示   ------回显确认---->         
     一般可以将报文段2和3进行合并

2、交互方法
     为了提高这类数据的发送效率和降低网络负担，TCP采用了两种策略：捎带ACK(时延的确认)和Nagle算法。
     (1) 时延的确认(延迟确认)
          通常TCP在接收到数据时并不立即发送ACK；它会推迟发送（时延为200ms），以便将ACK与需要沿该方向发送的数据一起发送
     (2) Nagle算法
          为了减少广域网的小分组数目(小于MSS的任何分组)，从而减小网络拥塞的出现
          该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组
          使用TCP套接字选项TCP_NODELAY可以关闭套接字选项
```

### TCP的成块数据流
```
[TCP缓存区与窗口的关系]https://blog.csdn.net/yxccc_914/article/details/52515558
[TCP的那些事]https://coolshell.cn/articles/11564.html
[TCP滑动窗口协议]https://www.jianshu.com/p/07bd39becbfd

滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。

1、数据传输中的标识
     例如：
                              Seq 1:1025(1024), win 4096
                              --------------------------->
                              Seq 1025:2049(1024), win 4096
                              --------------------------->
                              Seq 2049:3073(1024), win 4096
                              --------------------------->
                              ack 2049, win 4096            已收到2049个字节，当前窗口是4096
          4096-(3073-2049)    <---------------------------
                              ack 3073, win 3072            已收到3073个字节，当前窗口是3072(tcp缓存中上层应用还没读完)
          3072-(3073-3073)    <---------------------------
     
     Seq：发送包的序列号和数据大小，可以解决乱序问题 
     Ack：确认收到的序列号n，代表接收方已经接收到了前n-1字节数据。接收方不必确认每一个收到的分组，在TCP中，ACK确认是累积的，可以在接收到几个序号连续的报文段后只发送一个ACK确认报文，但累积等待的时间最长不能超过0.5秒，以防止发送端超时重传
     Win：TCP三次握手的前两次握手时协商好了发送窗口和接受窗口的大小，确定最大发送数据量
          数据传输过程中，发送方收到了接收方的win大小，来计算接下来可发送多少数据(假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n))，从而控制发送方的发送速度达到防止发送方发送速度过快而导致自己被淹没的目的。如果可发数据大小为0，则等待


2、滑动窗口
     > 窗口是缓存的一部分，用来暂时存放字节流
     > 发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小
     > 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收
     > 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态
     > 接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

     接收窗口只会对窗口内最后一个'按序到达'的字节进行确认
     例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认(ack 31)
     发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收

     (1) 窗口结构
                    提供的窗口（由接收方通告）
               +--------------+-------------+
          [1]  |     [2]      |    [3]      | [4] ->
               +--------------+-------------+
               |-> 合拢               收缩 <-|-> 张开
          [1] 发送并被确认
          [2] 发送但未确认
          [3] 可用的窗口(数据还未发送)
          [4] 不能发送直至窗口移动

          合拢：窗口左边沿向右边沿靠近，这种情况发生在数据被发送和确认时
          张开：窗口右边沿向右移动，这种情况发生在接收端进程从TCP接收缓存中读取了已经确认的数据并'释放'TCP接受缓存时
          收缩：窗口右边沿向左移动，一般很少发生，RFC也强烈不建议这么做，因为很可能会产生一些错误，比如一些数据已经发送出去了，又要收缩窗口，不让发送这些数据。另外，窗口的左边沿是肯定不可能左移的，如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK，并被丢弃

     (2) 缓存
          TCP缓冲区，也称套接字缓冲区。是应用进程读取和写入内核的区域
          发送缓存>发送窗口
          接收缓存>接收窗口

     (3) 缓存区与窗口的关系
          TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区
          1) 发送窗口
               |<------------------缓存------------------->| 
               |     |<---------窗口------->|              | 
               |-----↓---------------↓------|------↓-------|
              [0]   [1]             [2]    [3]    [4]     [5]

               [0]    缓存起始
               [0-1]  已经发送完的数据，可以丢弃     
               [1]    收到接收端ACK的位置(最后被确认的字节)，也是窗口的起始位置，向右滑动
               [1-2]  已发送的数据，但还没得到确认
               [2]    最后发送的字节
               [2-3]  可以被发送的数据(还没发送)
               [3]    窗口的终止位置，可以向右移动或不变
               [3-4]  缓存中的数据
               [4]    应用程序正在写的位置
               [5]    缓存终止   
               [1-3]  发送端窗口的大小根据接收端返回窗口大小而定(可发送数据=win-(seq-n))
               
          2) 接收窗口
               |<------------------缓存------------------->| 
               |             |-----------窗口-------|      | 
               |-----↓-------↓---□--□--↓------------|------|
              [0]   [1]     [2]       [3]          [4]    [5]

               [0]    缓存起始
               [0-1]  应用程序已经读取的数据
               [1]    应用程序正在读取的位置
               [1-2]  已确认接收的数据，但还没被应用程序读取
               [2]    最后确认接收数据的位置已发送ACK，向右移动
               [2-3]  接收发来的数据，但还没被确认，中间可能有没有收到的数据包
               [3]    当前接收数据最后的位置，没确认
               [3-4]  窗口内待接受数据内存
               [4]    窗口终止
               [5]    缓存终止
               [4-5]  当接收端源源不断收到发送端的数据，窗口[2-4]向右移动，当到缓存终点时，会导致[2-4]窗口越来越小。总之是由于应用程序不及时处理缓存中的数据
     
     (4) 特点
          > 发送方不必发送一个全窗口大小的数据
          > 发送方窗口大小可以变化，最右边不能向左移动
          > 接收方确认一个报文数据并把窗口向右边滑动
          > 接收方在发送一个ACK前不必等待窗口被填满

     (5) Zero Window
          1) 问题
               一个处理缓慢的接收端会把把发送端Sliding Window给降成0的，此时发送端会停止发送数据，但是接收端win可用时，怎么通知发送端呢？
          2) ZWP
               发送端会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，如果3次过后还是0的话，有的TCP实现就会发RST把链接断了

2、慢启动(控制流量发送的方式)
     (1) 发送方一次发送多少个报文段？
          发送方'并不会'一次发送多个直到达到接收方通告的窗口大小为止报文段
          因为在多个路由器和速率较慢的链路时，一些中间路由器必须缓存分组，并有可能耗尽存储器的空间
          所以发送方必须控制一次发送报文段数量

     (2) 拥塞窗口(cwnd)
          建立TCP连接时，拥塞窗口被初始化为1个报文段(计数的方式)，然后发送一个报文段。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段，当收到这两个报文段的ACK时，拥塞窗口增加到4(收到几个报文段增加几个)，然后发送4个报文段。一种指数增加关系
          例如
                         1:513(512), ack 1, win 4096
               cwnd=1    ------------------------------>    1

                         ack 513, win 8192
               cwnd=2    <------------------------------    2
               可发送2个报文段
                         513:1025(512), ack 1, win 4096
                         ------------------------------>    3
               
                         1025:1537(512), ack 1, win 4096
                         ------------------------------>    4

                         ack 1025, win 8192
               cwnd=3    <------------------------------    5
               可发送3个报文段
          
     (3) 算法过程
          1) 连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。
          2) 每当收到一个ACK，cwnd++; 呈线性上升
          3) 每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
          4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入"拥塞避免算法"(详见下)

          如果网速很快的话，ACK也会返回得快，RTT也会短


```

### TCP超时与重传
```
// RTT
发送请求到接受请求之间的时间
// RTO
重传超时时间，利用RTT来推导RTO
根据网络延迟，动态调整超时时间，延迟越大，超时时间越长

// 计算RTO的算法
经典算法、Karn/Partridge算法、Jacobson/Karels算法(TCP使用)


1、四种定时器
     (1) 重传定时器
          当A向B发送报文时，就会启动重传定时器，若在定时器到达之后，仍没有收到B的确认报文，则A会重新发送上次发送的报文
     (2) 坚持计时器
          在A(发送端)接收到B(接收端)发送的'0窗口'报文(ack)后，A(发送端)就设立坚持定时器，当定时器到达后，A就向B发送一个探测报文(ZWP)，B收到探测报文后会给出A确认报文(ack windows)
     (3) 保活定时器(keepalive)
          在服务器端设置保活计时器，服务器每收到客户机的一次消息，就重置保活计时器
          当服务端没有收到客户端消息时，服务端向客户端定时发送探测报文，若连续数个报文没有回应，则关闭连接
     (4) 2MSL定时器
          用于TCP四次挥手阶段。当客户端向服务器发送最后一次确认报文时，就设定一个时间等待及时器，等待2MSL时间后再结束连接


2、TCP重传机制
     时间驱动、数据驱动
     (1) RTO超时重传(时间驱动)
          > 每个数据包都有计时器
               每个数据包都有相应的计时器，一旦超过 RTO 而没有收到 ACK，就重发该数据包
          > 重传缓冲区
               没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除
          > 超时意味着拥塞
               超时重传是相当重要的事件，一旦发生这种情况，TCP 不仅会重传对应数据段，还会降低当前的数据发送速率，因为TCP 会认为当前网络发生了拥塞
          > 低效
               假设数据包5丢失，数据包 6,7,8,9 都已经到达接收方，这个时候客户端就只能等服务器发送 ACK
               注意对于包 6,7,8,9，服务器都不能发送 ACK，这是滑动窗口机制决定的
               因此对于客户端来说，他完全不知道丢了几个包，可能就悲观的认为，5 后面的数据包也都丢了，就重传这 5 个数据包，这就比较浪费了

     (2) 快速重传(数据驱动)
          不以时间驱动，而以数据驱动重传
          当收到3个重复的ACK时，发送方会重传此丢失的数据包
          // 例如
          发送方发出了1，2，3，4，5份数据
          接收方收到{1}，于是就ack回2；后续接收端收到了{3}，还是ack回2；后面的{4,5}也到了，但还是ack回2
          于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2(可能会重传3,4,5)
          接收端终于收到了{2}，因为上述3，4，5已经收到了，于是ack回6
          // 注意
          快速重传没有解决该重传多少个包
     (3) SACK
          快速重传的改进
          在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了
          在TCP头里加一个SACK的东西，ACK还是快速重传的ACK，SACK则是汇报收到的'数据碎版'
               

3、TCP的拥塞处理
     (1) 网络拥塞
          拥塞的主要成因是数据发送方投放到网络中的数据超出了网络的承载能力
     (2) 拥塞控制
          为了避免网络拥塞而导致的分组丢失，必须控制发送端每次发送的分组数
     (3) 为什么要控制流量
          如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高
          // 网络延时 -> 重传 -> 网络的负担更重 -> 网络更延时 -> 重传 -> 
          所以TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害
     (4) 避免拥塞算法
          拥塞控制算法对TCP性能影响很大，除了下面提到的AIMD算法，还有众多其他算法
          PRR(比例降速)是RFC 6937规定的一个新算法，其目标就是改进丢包后的恢复速度，现在是Linux 3.2+内核默认的拥塞预防算法

          AIMD算法:

          TCP控制两个变量cwnd(拥塞窗口)和sshthresh(拥塞窗口阈值)

          1) 慢启动(上面已讲到)
               1> 连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据
               2> 每当收到一个ACK，cwnd = cwnd + 1; 呈线性上升
               3> 每当过了一个RTT，cwnd = cwnd * 2; 呈指数让升
               4> cwnd存在上限sshthresh，当cwnd > sshthresh (拥塞避免)
               5> 每当收到一个ACK，cwnd = cwnd + 1/cwnd
               6> 每当过了一个RTT，cwnd = cwnd + 1
               避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法
          2) 拥塞发生
               拥塞发生时，表现是'会发生超时或收到重复的ACK'
               1> 发生超时
                    等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈
                    sshthresh =  cwnd / 2
                    cwnd 重置为 1
                    进入慢启动过程
               2> 收到重复的ACK
                    在收到3个重复ACK时就开启重传，而不用等到RTO超时(快速重传)
                    针对流量控制则进入快速恢复算法(Fast Recovery)
                    1> sshthresh =  cwnd / 2
                    2> cwnd = sshthresh  + 3 * MSS(3倍的报文段大小)
                    3> 重传丢失的报文段(不会对此进行确认<见上述>)
                    4> 如果又收到另一个重复的ACK时，cwnd = cwnd+1增加1个报文段大小并发送1个分组
                    5> 如果收到了新的ACK，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了(上述慢启动的第4步)

          3) 流程图
               1> 报文发送流程
                    慢启动
                    cwnd = 1
                    指数增大
                    cwnd >= ssthresh
                    拥塞避免
                    线性增长
               2> 上述任何步骤都可能发生'超时'或'3个重复ack'
                    1> 发生超时
                         sshthresh = cwnd/2  cwnd 重置为 1
                         跳到慢启动步骤继续开始
                    2> 收到3个重复ack
                         sshthresh = cwnd/2  cwnd = sshthresh
                         跳到拥塞避免继续开始

```

### TCP SYN队列和Accept队列
```
https://zhuanlan.zhihu.com/p/87437843
https://www.jianshu.com/p/35e8c7d38809
https://www.jianshu.com/p/e6f2036621f4

1、SYN队列
     (1) 作用
          SYN队列存储了收到SYN包的连接(对应内核代码的结构体：struct inet_request_sock)
          > 当收到客户端的SYN连接，回复SYN+ACK包，等待收到来自客户端的ACK。在没有收到ACK包时重传，直到超时
          > 当收到来自客户端的ACK包时
               > 首先找到对应的SYN队列，再在对应的SYN队列中检查相关的数据看是否匹配
               > 如果匹配，内核将该连接相关的数据从SYN队列中移除，创建一个完整的连接（对应内核代码的结构体：struct inet_sock），并将这个连接加入Accept队列
     (2) 队列大小
          SYN队列用于保存半连接状态的请求
          大小通过/proc/sys/net/ipv4/tcp_max_syn_backlog指定

2、Accept队列
     (1) 作用
          Accept队列中存放的是已建立好的连接，也即等待被上层应用程序取走的连接。当进程调用accept()，这个socket从队列中取出，传递给上层应用程序
     (2) 队列大小
          Accept队列用于保存全连接状态的请求
          其大小通过/proc/sys/net/core/somaxconn指定
          也可以在使用listen函数时，backlog参数指定，int listen(int sockfd, int backlog)
          最终取上面两个最小值
```

### TCP缓存接受队列
```
https://www.cnblogs.com/alreadyskb/p/4386565.html
http://www.cnhalo.net/2016/07/13/linux-tcp-prequeue-backlog/
https://zhuanlan.zhihu.com/p/121651317

1、三个缓存队列
     tcp协议栈数据接收实现了三个接收缓存队列
     prequeue、sk_receive_queue、sk_backlog

2、为什么需要多队列的原因
     进程上下文、中断上下文如果处理一个socket缓存队列时，必然会产生竞争(进程上下文与中断上下文对自旋锁的竞争)
     图例
          进程上下文(读取)
               ↓
          ---------socket 缓存队列------------   
               ↑
          中断上下文(写入)
     
     中断上下文自旋时间完全取决于进程上下文的行文，这不利于软中断的快速返回，极大地降低了系统的响应度

3、解决方案
     (1) tcp_v4_rcv
          tcp_v4_rcv函数是ip层到tcp层的入口，此函数描述了怎么分发数据包
     (2) 两个锁
          tcp协议栈对struct sock *sk有两把锁，第一把是sk_lock.slock，第二把则是sk_lock.owned
          sk_lock.slock用于获取struct sock *sk对象的成员的修改权限
          sk_lock.owned用于区分当前是进程上下文或是软中断上下文，为进程上下文时sk_lock.owned会被置1，中断上下文为0
     (3) 处理过程
          当协议栈收到数据包时，struct sock *sk可能被进程上下文或中断上下文占用
          > 当应用程序持有锁时
               进程上下文持有锁，软中断暂时拿不到锁，所以让数据暂存在后备队列中(backlog)
               当进程上下文处理完成后，释放锁，然后直接调用函数处理backlog队列里的数据
          > 当应用程序没有持有锁时
               那么处于中断上下文，数据可能被放置到receive_queue或者prequeue，数据优先放置到prequeue中，如果prequeue满了则会放置到receive_queue中
          总之为了更快速的结束软中断数据处理流程：
          协议栈(软中断上下文)先尝试把包加入backlog中，再尝试加入prequeue中，如果都不能则在软中断上下文中处理数据包。
          无论加到哪个队列，最终进程上下文都会调用tcp_v4_do_rcv函数将数据有效地插入到sk_receive_queue中，最后被应用层取走
     (4) 核心代码
          int tcp_v4_rcv(struct sk_buff *skb) {
               ...
               //获得slock锁(第一把锁)
               //要对sk修改，首先是必须拿锁sk_lock.slock
               bh_lock_sock_nested(sk); 
               tcp_segs_in(tcp_sk(sk), skb);
               ret = 0;
               //获得owned锁(第二把锁)，判断是是处于进程上下文还是中断上下文
               if (!sock_owned_by_user(sk)) {
                    // 处于中断上下文，优先放置prequeue队列中
                    if (!tcp_prequeue(sk, skb)) 
                         // 没有成功加入prequeue(可能prequeue已满)，则在软中断中直接处理(放置receive_queue中)
                         ret = tcp_v4_do_rcv(sk, skb);
               //处于进程上下文，则直接放到后被队列backlog中，等用户进程释放锁的时候处理          
               } else if (tcp_add_backlog(sk, skb)) {	
                    goto discard_and_release;
               }
               bh_unlock_sock(sk);
               ...
          }

     (5) backlog
          > sk_add_backlog
               tcp_add_backlog -> sk_add_backlog
               sk_add_backlog函数用于添加sbk到sk_backlog中
          > release_sock
               sk_backlog的处理必然中进程上下文进行
               release_sock函数用于backlog数据的接收
               此函数在进程中被tcp_recvmsg调用
               release_sock -> _release_sock -> sk_backlog_rcv -> tcp_v4_do_rcv
          
     (6) prequeue
          如果数据包加入backlog队列，则加入prequeue队列，如果prequeue队列满了，则直接加入到receive_queue队列中(软中断中直接处理)
          tcp_prequeue -> __skb_queue_tail(将包添加到prequeue尾部)
          如果prequeue满了:
               while ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)
			     sk_backlog_rcv(sk, skb1);
          否则唤醒用户进程，处理包

     (7) tcp_recvmsg
          函数功能：进程读完sk_receive_queue之后，如果没有读满应用程序缓存，则会处理prequeue和backlog队列
          顺序：读取sk_receive_queue数据 -> 处理prequeue队列 -> 处理backlog队列
```

### TCP的优化
```
https://mp.weixin.qq.com/s/SwYcLLKhvv2lCjgew3sv9A

重用已经建立的TCP连接    Keep-Alive
增大TCP的初始拥塞窗口
更改拥塞避免算法

```

### 粘包
```
TCP是基于字节流而不是消息包的协议，TCP层会把应用层过来的数据组成一个报文发出去。TCP没有"粘包"的说法
需要应用层自己去拆分
```













