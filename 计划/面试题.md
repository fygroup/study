### c++ 面试题
```c++
// 重载 重写
重载：是指允许存在多个同名函数，而这些函数的参数表不同
重写：是指子类重新定义父类虚函数的方法

// 多态
编译时多态：基于模板和函数重载方式，在编译时就已经确定对象的行为，也称为静态绑定。
运行时多态：面向对象的一大特色，通过继承方式使得程序在运行时才会确定相应调用的方法，也称为动态绑定，依赖于虚函数表


// 菱形继承
最底层的派生类继承了两个基类，同时这两个基类有继承的是一个基类，故而会造成最顶部基类的两次调用
虚继承可解决

// const与#define
对前者进行类型安全检查

// 数组与指针
数组在静态存储区或者在栈上被创建
指针随时指向任意类型的内存块
sizeof可知数组长度，但是数组作为函数的参数传递，数组退化为指针

// 引用与指针有什么区别
引用必须被初始化
引用初始化以后不能被改变
不存在指向空值的引用

// const char *
const char* ptr;    // ptr指向的内容不能更改
char* const ptr     // const 指针，不能修改ptr值

//  RAII
c++管理资源，避免内存泄漏的一种方式
典型的应用是智能指针，创建对象的时候使用智能指针接管，离开其作用域自动释放资源

// RTTI
RTTI即运行时类型识别，其功能由两个运算符实现
typeid运算符，用于返回表达式的类型，可以通过基类的指针获取派生类的数据类型
dynamic_cast运算符，具有类型检查的功能，用于将基类的指针或引用安全地转换成派生类的指针或引用

// c++ 11 特性
智能指针
lambda
类型推倒auto, decltype
右值引用，移动构造函数
nullptr
for_each

// 常用设计模式
工厂
单例
适配

// new/delete malloc/free
malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符
new/delete 调用构造/析构函数，malloc只管分配内存不管初始化

// new申请的数组能用free释放？
不可以，（1）free 不会调用析构函数，会引起内存泄漏；（2）new分配数组空间时会在头之前多分配了4个字节，如果用free释放会产生段错误

// 虚函数
当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定
一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表
通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用
虚函数最主要的性能开销在于它阻碍了编译器内联函数和各种函数级别的优化，导致性能开销较大

// 构造函数和析构函数可以是虚函数吗?
不可以，构造函数完成之前，虚函数表还没创建，也就无法通过vptr找到作为虚函数的构造函数

// 析构函数不是虚函数，会带来什么问题？
派生类的析构函数用不上，会造成资源的泄漏

// 左值和右值
左值: 有明确的存放地址的值
右值：没有具体的指代名，即无法通过地址访问，通常在赋值表达式结束后变销毁

// 移动
相比复制构造函数与复制赋值操作符，前者没有再分配内存，而是实现内存所有权转移
STL容器都实现了移动语义，大大优化STL容器

// 哈希冲突
开放寻址法：线性探测再散列；顺序查看表的下一单元，直至找到某个空单元，或查遍全表
再散列法：建立多个hash函数，若是当发生hash冲突的时候，使用下一个hash函数，直到找到可以存放元素的位置
拉链法：就是在冲突的位置上简历一个链表，然后将冲突的元素插入到链表尾端

// allocator
STL 通过 allocator 分配空间的
allocator调用malloc来分配内存，在给小型区块分配内存时可能会产生内存碎片问题。为了解决这个问题，STL中的allocator采用了双层级配置器
大于128 bytes使用第一级配置器，内存的申请和释放直接采用malloc和free
小于128 bytes采用第二级配置器，申请和释放通过内存池来管理
内存池大致原理
    预申请一个内存区
    将内存中按照对象大小划分成多个内存块
    维持一个空闲内存块链表，申请释放从链表中取

// 迭代器失效
(1) push_back导致迭代器失效
    vector在push_back的时候当容量不足时会触发扩容，导致整个vector重新申请内存，并且将原有的数据复制到新的内存中，并将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放
(2) insert和erase导致的迭代器失效
    插入操作导致vector扩容，迭代器失效原因和push_back相同
    插入操作引起vector内元素移动，导致被移动部分的迭代器失效

// vector resize/reserve
resize: 分配空间，初始化；reserve: 只分配空间
clear只是清空(析构)元素，没有释放空间，要释放空间可以用swap

// 异常
能用就用
构造函数没有执行完成抛出异常，所以不会调用析构函数；要注意处理成员变量和基类的释放
析构函数避免抛出异常，异常点之后的程序不会执行，会造成诸如资源泄漏的问题；异常传递会进行栈展开，过程中会执行资源析构，若其他对象在析构过程中也抛出异常，程序就挂了

// 类型转换
static_cast
const_cast
dynamic_cast
reinterpret_cast


// 死锁怎么产生的
// 死锁的四个条件
禁止抢占
    系统资源不能被强制从一个进程（线程）中退出，已经获得的资源在未使用完之前不能被抢占
等待和保持
    一个进程（线程）因请求资源阻塞时，对已获得的资源保持不放
互斥
    资源只能同时分配给一个进程（线程），无法多个进程（线程）共享。
循环等待
    一系列进程（线程）互相持有其他进程（线程）所需要的资源。
只有同时满足以上四个条件，才会产生死锁，想要消除死锁只需要破坏其中任意一个条件即可

// 如何处理死锁、避免死锁

// 日志系统
线程安全                
性能，写文件时互斥  写日志的操作放在单独的日志线程中，双缓存，一个缓存用来收集日志，另一个缓存用来落盘
分割

// 嵌套类
class A{
private:
    class B;
}
减少依赖: 其一减少原类不必要的头文件的依赖，加速编译；其二对Impl类进行修改，无需重新编译原类
隐藏类的实现：私有成员完全可以隐藏在共有接口之外，给用户一个间接明了的使用接口，尤其适合闭源API设计

// stl sort
数据量大 快排算法
快排分段后的数据量小于16，改用插入排序
如果递归层次过深，改用堆排序

// lambda
lambda表达式，可以让编译器对算法函数和lambda表达式内的代码逻辑整体做优化，而不是局部

// 零开销原则
不需要为没有使用到的语言特性付出代价
使用某种语言特性，不会带来运行时的代价

// coredump 原理
当程序发生内存越界访问等行为时，会触发OS的保护机制，此时OS会产生一个信号(signal)发送给对应的进程
当进程从内核态到用户态切换时，该进程会处理这个信号。此类信号（比如SEGV）的默认处理行为生成一个coredump文件。

// noexcept
可以用来阻止异常的传播和扩散

// 排查内存泄露
asan

// auto 和 decltype
auto可以自动类型推导，但无法定义变量类型，可以用于返回值和形参; decltype返回变量类型，和auto一样在编译器起作用

// 虚拟内存分区
代码段(.text)：保存程序二进制机器码，以及文本常量
bss段(.bss)：又称全局静态变量区，存储全局变量和静态变量
堆区
文件映射区：存储动态链接库及mmap函数进行文件映射
栈区

// stl 能否被继承
最好别这么做
stl中的容器类都是没有virtual析构的，所以其衍生类与基类并不符合IS-A关系，这种继承其实是为了重用代码，而从重用代码的角度来看，公有继承不如私有继承，继承不如组合。



```

## 多线程与并发
```c++
// 并行和并发
并行指的是多个任务在同一时刻同时在执行
并发是指在一个时间段内，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的

// 线程同步技术
自旋锁、互斥体、信号量、条件变量、读写锁、RCU

// 条件变量的坑
(1) 生产者先于消费者（消费者线程还没有执行到 wait）
(2) 假唤醒
添加条件判断

// Reactor(同步IO模型) 和 Proactor(异步IO模型)


> 同步互斥，异步非阻塞，回调的概念



线程安全性、mutex、条件变量、死锁、race condition、false sharing
```

### linux系统
```c++
// linux从上电到运行的过程
BootLader将相应的Kernel Image从硬盘上搬运到RAM中，接着程序掉转到Kernel的入口点，接下来便是启动操作系统了

// 线程、进程、协程

// 进程上下文
当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文

// daemon

// fork
子进程和父进程的地址空间独立，但并不会复制空间内容，而是copy-on-write。fork后，子进程和父进程独立运行

// traceroute
操作系统是怎么进行进程管理的
操作系统是如何做到进程阻塞的
进程之间的通信方式有哪些
线程是如何实现的
线程之间私有和共享的资源有哪些
一般应用程序内存空间的堆和栈的区别是什么
进程虚拟空间是怎么布局的
虚拟内存是如何映射到物理内存的
了解分页内存管理吗
什么是上下文切换
操作系统是怎么做的上下文切换
什么是大端字节，什么是小端字节
如何转换字节序
信号和信号量的区别是什么
锁的性能开销，锁的实现原理？


多线程如何同步
进程间的数据共享
锁都有哪些
自旋锁的原理
多线程怎么发送信号
线程怎么退出
内存的分类
一个栈多大
copy on write 
```

### 网络面试题
```
Linux网络I/O模型  阻塞I/O模型、非阻塞I/O模型、I/O复用模型、信号驱动I/O模型、异步I/O模型
I/O 多路复用
epoll 边缘 水平
tcp dup区别
TCP 怎么保证可靠传输
tcp滑动窗口的作用
tcp哪几种定时器
tcp拥塞控制
TCP 中间连接的时候断开会发生什么（重传、超时、等待状态、TCP 可靠连接原理）
tcp 3次握手，4次挥手，如果中间有一次丢掉处于什么状态
tcp 心跳，有tcp心跳为啥还用应用层心跳（http server）
TIME_WAIT？ close_wait?
大量TIME_WAIT产生的原因
设计一个文件断点续传
TCP 连接过程中客户端与服务端使用什么函数实现连接
如何解决粘包和半包问题？实际写过这方面的网络通信程序吗


SYN超时
SYN Flood，应对方式是什么？

```

```c++
shared_ptr的引用计数是怎么存储的
shared_ptr是线程安全的吗
vecotr<int> a； a中数据在堆上还是栈上
vector的clear()的时间复杂度是多少
在vector变量的有效期内，释放其中元素所占的内存
&，const &， &&的理解
C++11为什么引入nullptr
C++11的thread_local
std::thread使用lambda做回调，有没有什么注意事项？
lambda 如何实现
core dump的原因有哪些，内存泄露的常见原因有哪些，如何排查？
c++ 异常如何实现的，异常使用注意事项
怎么分析代码，找出性能优化点
虚函数相关
虚函数和纯虚函数
左值右值
什么是多态
构造函数和析构函数能不能是虚函数，为什么析构需要虚函数
单例模式、多线程处理单例模式
c语言如何实现 多态、继承、封装
auto变量的使用注意事项（不能定义数组）
vector 和 list 的区别
vector 存放数据的注意
vector 的内部机制
weak_ptr 原理
深拷贝与浅拷贝区别
// STL怎么解决哈希冲突  开放寻址法、再散列法、拉链法
如何避免内存泄漏
strcpy 和 memcpy区别
什么是迭代器失效
new 和 malloc 的区别
静态多态包含什么类型
重载与重写的区别
为什么用extern "C"{}
嵌套类的用处
C++的 sort 函数是怎么实现的
MVC 模式
```


### 算法
```
常用的排序算法 （时间 空间复杂度）
图算法
树
双链表和单链表的优缺点
用两个栈实现一个队列
找出数组中次数最多的前 k 个数
大量数据无序输入，怎么有序输出？ （使用最大堆最小堆）
怎么获取二叉树的高度
红黑树好处
动态规划与贪心算法的区别（背包问题分析）
```

### 音视频
```
FFmpeg 中对视频和音频的同步方法
rtmp协议
音视频切换的多线程怎么处理帧切换的问题
视频播放器设计
视频播放器用到 FFmpeg 哪些库
H264 编解码原理
有几种 NAL，如果在视频中存放信息存放在哪个帧
怎么设置压缩码率
边下边播用什么协议
MP4 包含了什么协议
直播用的什么协议
TS 流有什么内容
怎么传递视频信息
怎么解决视频卡顿问题
音视频解码过程的格式
视频播放器开发的过程
YUV 格式与 RGB 格式的区别
AVFrame Parma 的意思
音频3A
```

### 大数据处理
```

```

### 项目
```

盒子
流媒体rtsp -> live555解复用 -> HI_MPI_VDEC_SendStream -> HI_MPI_VPSS_GetChnFrame -> yuv 图片帧

人像检测 track -> 人脸人体质量过滤 -> 属性提取 -> 特征提取 -> 比对
                                            -> 入库
入库 —> 图片检测 -> 抠图人像 -> 质量过滤 -> 特征值提取 -> 入库

双目
hisi_input -> tracker -> tracker_trans -> OSD叠加 -> roi叠加
expose
fusion

// VI获得相机的流，然后算法处理每一帧，然后送入VENC进行编码
VI -> hisi_input -> track_trans -> HI_MPI_VENC_SendFrame -> VENC

// 获得编码后的流送入缓存
HI_MPI_VENC_GetStream -> HI_DOWSE_VENC_Proc_Cb -> hi_pool_write_frame

// rtsp获得缓存数据推送
RTSP： hi_pool_read_frame -> hi_rtsp_get_video_data 


架构的梳理 代码开发与维护

基于wukong os
device network media ai
APP -> API -> service -> HAL

(1) device
App     device_app
Api     device_manager sensor_manager
Service led gpio crypt door
Hal     

(2) network
App     
Api     network wifi 
Service 
Hal     以太网  wifi  蓝牙

(3) media
App     
Api     camera_manager media_manager
Service camera_service media_codec media_play_service
Hal     himpp

(3) AI
Api     ai_manager
service ai_sdk

(4) system
Api     NetManager SleepManager IOManager  OTAManager
Service network   file io、timer、cpu run、memory
        网络    文件/设备 定时器  cpu耗时   内存 

media   处理相机、流媒体的 流的收发、处理和推送
ai      分析帧数据 用ai_sdk进行 抓取、过滤、特征、属性
storage 数据库、图片文件的存储 设计加解密
web     与前端交互、后端业务流程
adaptor 适配服务：万物智联、mqtt、电梯控制、门禁等

不同的模块相互解耦，各种异步调用，通过zmq库实现

智能边缘盒子
双目智能相机
aiop智能相机
端边设备万物智联模块
```

### 重点技术
```
c++
    智能指针, 虚函数, stl

mqtt
    QoS retain 心跳 遗嘱

mysql

tcp/ip socket

grpc protobuf
    T - L - V 的数据存储方式

c++ 高并发业务架构
    wukong os

ZMQ
    为什么使用消息队列？解耦
    它封装了网络通信、消息队列、线程调度等功能
    请求应答、发布订阅、管道、点对点
    zmp_tcp         TCP的单播通信   tcp://*:8080
    zmp_ipc         本地进程间通信  ipc://
    zmp_inproc      本地线程间通信  inproc://
    zmp_pgm         PGM广播通信     pgm://

基于hisi要讲清楚
arm neon
I2C、SPI、CAN、gpio
AUTOSAR
quic dpdk
吹分布式


怎么定位 cpu 内存 高负载
如何故障排除
相关调试技术


// 设计模式
SOA架构
中间件设计架构
项目介绍
    link 架构
    电梯 CAN控制
    ota 升级


```

### c++高并发业务架构
```
（1）架构设计
资源和任务
任务流

针对系统资源分为 network、file io、timer、cpu run、memory
                网络    文件/设备 定时器  cpu耗时   内存 

NetRequest SleepRequest IORequest ExecRequest

调度器去操作上面系统资源，就是操作一批网络连接或者说线程，分为以下几点
> 包含与管理资源池
> 实现如何对一批连接尽可能高性能地响应其读写、如何尽可能快且尽可能通用地给出一个足够灵活的机制去让各线程执行各种计算
> 提供请求接口给上层使用

以线程执行器Executor为例
class Executor
{
public:
    // 一次要执行的接口，对于线程执行器来说，就是把一个执行任务扔进某个队列中
    int request(ExecSession *session, ExecQueue *queue);
private:
    // 执行器和系统资源，是一个包含关系
    thrdpool_t *thrdpool;
};



（2）业务设计



服务层

系统资源层

```
