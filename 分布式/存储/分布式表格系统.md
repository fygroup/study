### 表格系统特点
```
分布式表格系统对外提供表格模型，每个表格由很多行组成，通过主键唯一标识，每一行包含很多列。整个表格在系统中全局有序
```

### Google Bigtable
```
Bigtable是Google开发的基于GFS和Chubby的分布式表格系统

1、数据模型
    Bigtable是一个稀疏的、分布式的、持久化存储多维度排序Map
    Map的索引是行关键字 、列关键字以及时间戳
    Map中的每个value都是一个未经解析的byte数组

    key ---> value                                         
    (row:string,column:string,timestamp:int64) ---> string
    
    // 实例
        存储网页数据(Webtable)
        使用URL作为行关键字，使用网页的某些属性作为列关键字
        '行名(行关键字)'是反向URL
        'contents列族'存放网页的内容，并用时间戳做标识
        'anchor列族'存放引用该网页的锚链接文本

        URL             'contents:'     'anchor:cnnsi.com'  'anchor:my.look.ca'
        +-------------+----------------+-------------------+--------------------+
        |'com.cnn.www'|  '<html>' <-t6 |  'CNN' <-t8       |  'CNN.com' <-t5    | 
        |             |  '<html>' <-t5 |                   |                    | 
        |             |  '<html>' <-t4 |                   |                    |     
        +-------------+----------------+-------------------+--------------------+


    > 行
        > 原子性
            对同一行的读或写都是原子的(不管读或写这一行有多少不同的列)
        > 顺序性
            通过行关键字的字典顺序来组织数据
        > Tablet
            表中的每一行都可以动态分区
            每个分区叫做一个'Tablet'
        > Tablet功能
            Tablet是'数据分布和负载均衡'调整的最小单位
            优点：操作只读取行中很少几列的数据效率很高，需要很少的机器通信
            例如：Webtable中，反转URL可以把同一域名下的网页'聚'集起来组成'连续的行'

    > 列族
        列关键字组成的集合叫做列族，列族是Bigtable中访问控制的基本单元
        > 同一种类型
            同一列族同一种类型(利于压缩)
        > 列族的稳定性
            使用前要先创建，而且不能太多(几百个)，很少改变比较固定
        > 无限个列
            列族创建后，在其下可以创建无限个列
        > 列关键字
            列族:限定字
        > 功能
            '访问控制、磁盘和内存的使用统计'都是在列族层面进行的
   
   > 时间戳
        > 版本
            每一个数据项都包含不同的版本，不同的版本利用时间戳来索引
        > 倒序
            时间戳是64位整型，倒序排序，最新的数据排在最前面
        > 删除冗余
            可以指定只保存'最后n个版本'或者只保存'一定时间的数据'

    > 事务性
        > 单行上的事务处理
            BigTable对'一行'关键字下的数据操作具有事务性(进行原子性的读-更新-写操作)
        > 不支持跨行事务
        > 允许把数据项用做整数计数器

2、BigTable 架构
    BigTable是构建在google基础组件上的。例如集群调度系统用来故障恢复与监控；GFS用来存储日志及子表SSTable数据；Chubby锁服务用来存储元数据执行Master选举

    (1) 依赖google基础组件
        BigTable构建在GFS之上，为文件系统增加了一层分布式索引层
        BigTable依赖Chubby进行服务器选举及全局信息维护
        Bigtable将大表划分为大小在100~200MB的子表(tablet),每个子表对应一个连续的数据范围
        1) SSTable
            BigTable内部数据存储是的文件是SSTable格式的
            > Map结构
                SSTable是一个持久化、排序的、不可更改的Map结构(key-value)
                查询与一个 key 值相关的 value,或者遍历某个 key 值范围内的所有的 key-value 对
            > 数据块
                SSTable 是一系列的数据块(64KB)
                SSTable 使用块索引来定位数据块
                在打开 SSTable 的时候,索引被加载到内存
            > 数据查找
                每次查找都可以通过一次磁盘搜索完成
                首先使用二分查找法在内存中的索引里找到数据块的位置, 然后再从硬盘读取相应的数据块
                也可以选择把整个 SSTable 都放在内存中,这样就不必访问硬盘了

        2) Chubby服务
            BigTable 还依赖一个高可用的、序列化的分布式锁服务组件
            > 主控服务器选取
                选取并保证同一时间内只有一个主控服务器
            > 存储Bigtable系统引导信息
            > 用于配合主控服务器发现子表服务器加入和下线
            > 获取Bigtable表格的schema信息及访问控制信息
            > Chubby服务部署在多个数据中心，典型的部署为两地三数据中心五副本，同城的两个数据中心分别部署两个副本，异地的数据中心部署一个副本，任何一个数据中心整体发生故障都不影响正常服务

    (2) 组成架构
        BigTable由Client、Master、Tablet Server构成
        Bigtable将大表划分为大小在100~200MB的子表(tablet),每个子表对应一个连续的数据范围

        1) Master、Client和Tablet server
            1> Master
                主要参与管理所有的子表服务器
                > 检测新加入或失效的Tablet服务器
                > 分配子表给子表服务器，为Tablet服务器分配Tablets
                > 对 Tablet 服务器进行负载均衡
                > 对保存在 GFS 上的文件进行垃圾收集
                > 指导子表服务器实现子表的合并
                > 接受来自子表服务器的子表分裂消息

            2> Client
                > 提供API
                    提供Bigtable到应用程序的接口，对表格的数据单元进行增、删、查、改等操作
                > 与字表服务器直接通信    
                    客户端通过Chubby锁服务获取一些控制信息，但所有表格的数据内容都在客户端与子表服务器之间直接传送
            
            3> Tablet Server
                每个Tablet服务器管理一个Tablet的集合(十个至上千个Tablet)
                每个 Tablet服务器负责处理它所加载的 Tablet 的读写操作,以及在 Tablets 过大时,对其进行分割
                > 子表的操作
                    实现子表的装载/卸出、表格内容的读和写，子表的合并和分裂
                > 日志的操作
                    Tablet Server操作日志，存储在GFS上
                > 数据的操作
                    Tablet Server服务操作每个子表上的sstable数据，这些数据存储在底层的GFS中

        2) Tablet的分布
            Bigtable按照行键的字典序存储数据。Bigtable的表会根据行键自动划分为片（tablet），片是负载均衡的单元
            最初表都只有一个片，但随着表不断增大，片会自动分裂，片的大小控制在100-200MB

            chubby文件 ---> 根表 ---> 元数据表 ---> 用户表

            1> 三种类型的Tablet
                > 用户表(User Table)
                    用户表存储用户实际数据
                > 元数据表(MetaTable)
                    元数据表存储用户表的元数据，如子表位置信息、SSTable及操作日志文件编号、日志回放点等
                > 根表(RootTable)
                    根表用来存储元数据表的元数据
                    根表的元数据，又称为Bigtable引导信息，存放在Chubby系统中。客户端、主控服务器以及子表服务器执行过程中都需要依赖Chubby服务,如果Chubby发生故障,Bigtable系统整体不可用

            2> 元数据
                Bigtable中包含两级元数据,元数据表(MetaTable)及根表(RootTable)
                子表(Tablet，userTable)分裂的时候需要修改元数据表，元数据表的某些操作又需要修改根表
                通过使用两级元数据,提高了系统能够支持的数据量
                // 例如
                一个Tablet大小为128M，一个Tablet的元数据为1K，两级元数据支持 128M * 128M * 128M = 1048P

            3> 查询数据
                首先从Chubby中读取根表的位置，接着从根表读取所需的元数据子表的位置，最后就可以从元数据子表中找到待查询的用户子表的位置
                > 提高查询性能
                    为了减少访问开销,客户端使用了缓存(cache)和预取(prefetch)技术
                    > 缓存
                        子表的位置信息被缓存在客户端,客户端在寻址时首先查找缓存
                        一旦缓存为空或者缓存信息过期,客户端就需要请求子表服务器的上一级元数据表获取位置信息
                        子表缓存过期需要请求元数据表,元数据子表缓存过期需要请求根表,根表缓存过期需要读取Chubby中的引导信息
                    > 预取
                        每次访问元数据表时不仅仅读取所需的子表元数据,而是读取连续的多个子表元数据,这样查找下一个子表时不需要再次访问元数据表

5、复制与一致性
6、容错
7、负载均衡
8、分裂与合并
9、








```