### 数据库存储引擎
```
1、哈希存储引擎(key-value)
	Bitcask是一个基于哈希表结构的键值存储系统，它仅支持追加操作
	支持增、删、改，以及随机读取；不支持顺序扫描；写操作只追加而不修改老的数据
	1) 数据结构
		> 文件
			活跃数据文件和老数据文件
			数据是一条一条的写入操作
			每一条记录的数据项分别为主键、value、主键长度、value、时间戳以及crc校验值
		> 哈希表
			内存中采用基于哈希表的索引数据结构，通过主键快速地定位到value的位置
			哈希表结构中的每一项包含了三个用于定位数据的信息，分别是文件编号（file id），value在文件中的位置（value_pos），value长度（value_sz）
		写入时
			首先将Key-Value记录追加到活跃数据文件的末尾
			接着更新内存哈希表
		因此，每个写操作总共需要进行一次顺序的磁盘写入和一次内存操作

	2) 定期合并
		> 记录删除或者更新后，原来的记录成为垃圾数据
		> 要定期执行合并（Compaction）操作以实现垃圾回收
		> 将所有老数据文件中的数据扫描一遍并生成新的数据文件
		> 对同一个key的多个操作以只保留最新一个的原则进行删除，每次合并后，新生成的数据文件就不再有冗余数据
	3) 快速恢复
		Bitcask通过索引文件来提高重建哈希表的速度	
		索引文件就是将内存中的哈希索引表转储到磁盘生成的结果文件

2、B-Tree
	B树存储引擎不仅支持随机读取，还支持范围扫描
	> 叶子节点保存每行的完整数据，非叶子节点保存索引信息
	> 每个节点中有序存储，数据库查询时需要从根节点开始二分查找直到叶子节点
	> 修改操作首先需要记录提交日志，接着修改内存中的B+树
	> 内存中的被修改过的页面超过一定的比率，后台线程会将这些页面刷到磁盘中持久化
	> B 与 B+
		> 不同点
			> 内部节点中，关键字的个数与其子树的个数相同，不像B树种，子树的个数总比关键字个数多1个
			> 所有指向文件的关键字及其指针都在叶子节点中，不像B树，有的指向文件的关键字是在内部节点中。换句话说，B+树中，内部节点仅仅起到索引的作用，
			> 在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支。
		> 优点
			> B+树的磁盘读写代价更低
				B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小
			> B+树的查询效率更加稳定
				由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
			> B+树更有利于对数据库的扫描
				B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的range query，B+树有着更高的性能
3、LSM(key-value)
	[LSM 算法的原理]https://www.zhihu.com/question/19887265
	[levelDB Compaction]https://zhuanlan.zhihu.com/p/46718964
	[LSM-tree 基本原理及应用]https://cloud.tencent.com/developer/news/340271

	LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件
	(1) 存储结构
		k-v的数据结构是skiplist
		MemTable、Immutable MemTable、Current 文件、清单文件、日志文件、SSTable
		> MemTable是k-v结构，写入的值加入结构中(有序)
		> SSTable文件是内存中的数据不断进行Compaction操作后形成的
		> SSTable的所有文件是一种层级结构
		> 共有6层，0->5 逐渐增大，每层的SSTable是按照主键排序，每个文件有最小和最大键值

	(2) 写操作
		1) 数据首先会被写到log，保证持久性
		2) 然后写入memtable中，返回
		3）当 memtable 内存到达一定大小之后就会变成 immutable memtable
		4) 当到达一定的条件后，后台的 Compaction 线程会把 immutable memtable 刷到盘中 Level 0 中 sstable
		5) 当 level i 到一定条件后（某个 level 中的数据量或者 sstable 文件数据等）就会和 level i+1 中的 sstable 进行 Compaction，合并成 level i+1 的 sst 文件
	(3) 读操作
		1) 查询时首先会搜索内存中的MemTable，如果有则返回
		2) 如果没有读到，则搜索内存中的immutable Memtable，如果有则返回
		3) 如果没有读到，从新到老一层一层读取磁盘中的SSTable文件

	(4) Compaction
		为了提高读性能，执行Compaction操作来对已有的记录进行整理压缩，从而删除一些不再有效的记录，减少数据规模和文件数量
		分两种：minor compaction和major compaction
		1) minor compaction
			immutable memtable持久化为 SSTable 文件
		2) major compaction
			每个层级下有多个SSTable，当某个层级下的SSTable文件数目超过一定设置值后，levelDB会从这个层级中选择SSTable文件，将其和高一层级的SSTable文件合并
			> 目的
				均衡各个level的文件数量，提高read性能
				合并delete和update数据，释放磁盘空间
			> 细节
				在 Manual Compaction 中会指定的 begin 和 end，它将会一个level 一个level 的分次的Compact 所有level 中与begin 和 end 有重叠（overlap）的 sst 文件
```

### key-value数据结构
```
目前常用的key-value数据结构有三种：Hash表、红黑树、SkipList(跳表)

Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。
红黑树：插入、查找为O(log n)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。
SkipList：插入、查找为O(log n)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。

skipList的实现比红黑树简单，但性能要低于红黑树

redis和levelDB用的是skipList
```

### 数据分类
```
(1) 结构化数据
    结构化的数据的存储和排列是很有规律的, 一般存取到数据库

(2) 半结构化数据
    json、xml，半结构化数据的扩展性是很好的

(3) 非结构化数据
    没有固定结构的数据。各种文档、图片、视频/音频等都属于非结构化数据
```

### 数据库存储分类(数据模型)
```
1、文件存储
	提供了POSIX标准的文件操作接口，但是POSIX标准适合单机文件系统，在分布式文件系统中，出于性能考虑，一般不会完全遵守这个标准
	非结构化的文件/对象模型，文件、图片、视频、文档等二进制数据
	(1) 分布式文件系统
    HDFS、GFS、ceph（虚机块存储）
		主要思想是master管理、chunks存储并保存多个副本、自动容错恢复
        吞吐率都非常好，适合大文件。无法支持随机访问
	(2) 分布式对象存储系统
		HDFS+HBase(HBase存元数据，利用HDFS的Append功能将小文件合并成大文件)
    	swift（restful对象存储）

2、关系型数据库
	每个关系是一个表格，由多个元组（行）构成，而每个元组又包含多个属性（列）
	关系名、属性名以及属性类型称作该关系的模式（schema）
	> SQL语言用于描述查询以及修改操作
		修改包含三条命令：INSERT、DELETE以及UPDATE，查询通常通过select-from-where语句来表达
	
	> SQL两个重要特性
		索引：减少SQL执行时扫描的数据量，提高读取性能
		事务：保证了多个操作并发执行时的ACID特性
	
3、键值模型数据库(非关系型)
	> 大量的NoSQL系统采用了键值模型
	> 每行记录由主键和值两个部分组成
	> 基于主键的操作
		Put：保存一个Key-Value对
		Get：读取一个Key-Value对
		Delete：删除一个Key-Value对
	> K-V模型过于简单，与关系模型不同，k-v(表格模型)一般不支持多表关联操作，事务操作支持也比较弱


4、sql和nosql
	不存在谁取代谁
	传统sql面对高数据量和高并发力不从心
	nosql具有良好扩展性、弱化设计范式、高数据量和高并发有一定的解决能力
	nosql缺少保持ACID、join和SQL等特性，不保证强一致性的(支持最终一致)
```

### 数据库存储分类(数据模型)
```

2、sql数据库
	针对结构化数据的存储
	适合OLTP场景
	事务处理系统或者关系型数据库
	MySQL和中间件

3、nosql数据库
	主要是键值数据库，针对结构化/半结构化数据
	适合OLAP场景
  	(1) Key-value
      	Redis、LevelDB(谷歌)、RocksDB(facebook)
  	(2) 列数据库
      	Hbase
    (3) 文档数据库
        MongoDB
    (4) 图 Nosql
        Neo4j
    (5) 时间序列
        influxDb

```

### 拆分
```
垂直拆分
	是指按功能模块拆分，比如可以将群组相关表和照片相关表存放在不同的数据库中，这种方式多个数据库之间的表结构不同。比如在设计大型论坛时，我们可以把不同版面的数据存储到不同的数据库表或者不同的数据库中。
水平拆分
	而水平拆分是将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构完全相同。刚才说到的千万级的用户表所用到的办法就是水平拆分。
```

### 数据仓库的基本架构
```
http://webdataanalysis.net/web-data-warehouse/data-warehouse-frame/
https://www.zhihu.com/question/20623931
https://www.cnblogs.com/muchen/p/5318808.html
https://www.cnblogs.com/muchen/p/5310732.html
https://www.cnblogs.com/muchen/p/5305658.html

1、数据库和数据仓库
	OLTP与OLAP的区别
	(1) 数据库和数据仓库(DW)
		1) 数据库 
			传统的关系型数据库，主要用于事务处理
			一般指OLTP(联机事务处理)，面向用户
		2) 数据仓库(DW)
			用于数据分析，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果
			一般指OLAP(联机分析处理)，面向分析人员
	(2) 操作型数据库和分析型数据库
		1) 操作型数据库
			主要用于业务支撑。一个公司往往会使用并维护若干个数据库，这些数据库保存着公司的日常操作数据，比如商品购买、酒店预订、学生成绩录入等
			用于OLTP业务
		2) 分析型数据库
			主要用于历史数据分析。这类数据库作为公司的单独数据存储，负责利用历史数据对公司各主题域进行统计分析
			用于OLAP业务
	(3) 数据仓库特点
		数据仓库的数据是面向主题的
		数据仓库的数据是集成的
		数据仓库的数据是不可更新的
		数据仓库的数据是随时间不断变化的


2、数据仓库数据模型
	http://lxw1234.com/archives/2018/01/890.htm
	(1) 关系模型
		ER模型，范式模型
		优点：从关系型数据库的角度出发，结合了业务系统的数据模型，能够比较方便的实现数据仓库的建模
		缺点：构建成本高，由于建模方法限定在关系型数据库之上，需要深入了解业务；限制灵活性，性能低

	(2) 维度模型
		按照事实表，维表来构建数据仓库，星形模型
		优点：构建周期短，快速响应需求；性能好
		缺点：没有关系模型的优点
		1) 维
			维度模型的概念出自于数据仓库领域，是数据仓库建设中的一种数据建模方法。维度模型主要由事实表和维度表这两个基本要素构成
		2) 数据维度建模
			1) 两个概念
				1> 维度表
					表示对分析主题所属类型的描述，维度表信息比较固定，且数据量小
					比如"昨天早上张三在京东花费200元购买了一个皮包"。那么以购买为主题进行分析，可从这段信息中提取三个维度：时间维度(昨天早上)，地点维度(京东), 商品维度(皮包)
				2> 事实表
					表示对分析主题的度量。比如上面那个例子中，200元就是事实信息。事实表包含了与各维度表相关联的外码，并通过JOIN方式与维度表关联
			2) 三种模式
				1> 星形模式
					由一个事实表和一组维表成
					维表只和事实表关联，维表之间没有关联
				2> 雪花模式
					对星形模式的扩展，每个维表可继续向外连接多个子维表
					不满足规范化设计，开发难度大，数据冗余
				3> 星座
					很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到
					多维度，多事件，维度之间不能直接联系，只能通过事件联系

2、数据仓库架构
	(1) 架构分层
		数据流入流出的过程，可以分为四层: 源数据库、ETL、数据仓库、前端应用
		
		源数据		日志数据	数据库数据(OLTP)	文档数据	其他
								 |
		ETL						 |	
								 ↓
		数据仓库	聚合数据	多维数据(OLAP)	业务模型	细节数据
								 ↓
		应用层		展示、查询、挖掘、分析
	
	(2) ETL
		数据仓库开发中最耗时的阶段
		ETL工作的实质就是从各个数据源提取数据，对数据进行转换
		并最终加载'填充'数据到数据仓库维度建模后的表中

		源系统 -> 抽取 -> 清洗 -> 规范化 -> 提交(生成维度表和事实表) -> 聚集(根据事务事实表进行更高粒度的聚合以及生成相对应的维度表)
	
	(3) OLAP/BI工具
		数据仓库是数据处理的后台，业务用户并不关心后台怎么处理
		BI应用是数据呈现的前台，是业务用户进行查询的入口
		BI应用程序的体验也是衡量数据仓库是否成功的主要因素

	(4) 数据立方体(Data Cube)
		在真实世界里我们分析数据的角度很可能有多个，数据立方体可以理解为就是维度扩展后的二维表格
		常见操作(OLAP操作)
			下探(Drill down)：维度是有层次的，下探表示进入维度的下一层
			上钻(Drill up)： 下探的反向操作，回到更高汇聚层的汇总数据
			切片(Slice)：切片可以理解成把立体按某一个维度进行切分
			切块(Dice)：相对于切片是按一个点切分，切块就是按一个范围(区间)来做切分
			旋转(Pivot)：维的行列位置交换，换一个视角分析数据


```

### OLAP和OLTP
```
1、OLAP
	https://www.cnblogs.com/mq0036/p/4155832.html
	https://blog.csdn.net/xwc35047/article/details/86369465
	https://www.cnblogs.com/muchen/p/5318808.html
	https://blog.csdn.net/weixin_42529806/article/details/97615618

	联机分析处理（Online Analytical Processing）
	主要做数据仓库，主要对数据的查询，读多写少，做分析处理，复杂的分析操作，主要应用于大规模计算系统
	(1) 特点
		场景：分析决策，报表统计
		要求：无需事务支持
		数据操作：查询为主
		实时性：低
		DB大小：大(GB-TB)
		强调大数据高吞吐量
	(2) OLAP架构模式
		1) 基于MPP架构的ROLAP
			ROLAP架构并不会生成实际的多维数据集
			查询没有MOLAP快速。因为ROLAP中，所有的查询都是被转换为SQL语句执行的。而这些SQL语句的执行会涉及到多个表之间的JOIN操作

					 查询			  查询
			数据仓库 -----> ROLAP服务 -----> OLAP/BI 工具

			代表：Presto(Facebook/java)、Impala、Drill、Spark SQL

		2) 基于预计算的MOLAP
			MOLAP架构会生成一个新的多维数据集，也可以说是构建了一个实际数据立方体
			由于数据预先计算好，查询非常快速。但是由于立方体的更新比较慢，所以是否使用这种架构得具体问题具体分析

					 周期加载 			   查询	
			数据仓库 ---------> MOLAP服务 ------>  OLAP/BI工具

			代表：Druid(alibaba/java)、Kylin(Apache/java)
		
	(3) 不推荐Hive，太慢

2、OLTP
	https://www.talkwithtrend.com/Article/248323

	联机事务处理（Online Transaction Processing）
	事务性非常高，主要对数据的增删改
	典型的OLTP系统有电子商务系统、银行、证券
	强调高并发，实时性
	把这类数据库又叫做newsql，有两种实现方式
	(1) 数据库访问中间件(分库分表)
		依靠传统的关系型数据库，通过数据库分库分表的方式，满足扩展性要求
		MySQL、postgresql、中间件(Cobar、MyCAT)
		优点：中间件可以自由发挥
		缺点：在保证分布式事务一致性时，性能有所下降
	(2) NewSQL数据库
		1) 概念
			针对OLTP的读写，提供与NOSQL相同的可扩展性和性能，同时能支持满足ACID特性的事务
			即保持NoSQL的高可扩展和高性能，并且保持关系模型
		2) 为什么需要NewSQL
			NoSQL 不能完全取代 RDBMS
			单机RDBMS 无法满足性能需求
			使用“单机RDBMS + 中间件”方式，在中间件层很难解决分布式事务、高可用问题
		3) 案例
			Google Spanner/F1
			TiDB(开源)
			OceanBase
		优点：见上述
		缺点：无法人工干预(内部支持分库分表)，业界案例少，可靠稳定有待验证

```
