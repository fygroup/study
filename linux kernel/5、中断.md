### 中断相关概念
```
> 中断栈
    X86上中断栈就是独立于内核栈(ARM上中断栈和内核栈则是共享的)
    多处理器系统，每个处理器都会有一个独立的中断栈和软中断栈

> 类型
    中断一般分为异步中断(一般由硬件引起)和同步中断(一般由处理器本身引起)。
    把同步和异步又叫做异常和中断
    > 中断
        硬件的电信号随机产生
        > 可屏蔽: I/O设备发出的中断请求(IRQ)可被CPU忽略相应
        > 不可屏蔽: 不能用软件进行屏蔽，如硬件故障
    > 异常
        由cpu控制单元产生，只有在一条指令终止执行后cpu才发出中断。比如：系统异常处理(比如运算中的除0操作)
        处理器探测异常，分为：故障（fault）、陷阱（trap）、异常终止（abort）、编程异常（programmed exception）
        应用程序出现异常后，需要内核来处理
        内核调用相应的异常处理函数来处理异常
        处理完后终了应用程序或者给出message

> 中断与抢占
    禁止中断也就禁止了内核抢占
    硬中断和软中断（只要是中断上下文）执行的时候都不允许内核抢占，换句话说，中断上下文中永远不允许进程切换

> IRQ
    每个能够发出中断请求的硬件设备都有一条IRQ的输出线
    所有现有的IRQ线都与一个名为可编程中断控制器(PIC)的硬件电路输入引脚相连
    1) 监视IRQ线，检查产生的信号。如果有两条以上的IRQ线产生信号，就是选择引脚编号较小的IRQ线
    2) 当一个IRQ线产生信号时：
        1) 把接收到的引发信号转换成对应向量
        2) 把这个向量放到PIC的一个I/O端口，从而允许cpu通过数据总线读取向量
        3) 把引发信号发送到cpu的INTR引脚，即产生一个中断
        4) 等待，直到cpu把这个信号写进PIC的一个I/O端口来确认它，才清空INTR线
        5) 到1)
    3) 可以禁止IRQ线

> 高级PIC(APIC)
    为了充分发挥SMP(对称多处理)体系结构的并行性，引入了更高级的PIC，又名APIC
    每个处理器包含一个本地APIC，所有的本地APIC都连接到一个外部的APIC。
    +--------+          +--------+
    |  cpu0  |          |  cpu1  |
    |  APIC  |          |  APIC  |      本地APIC
    +--------+          +--------+    
        |                   |
        |                   |
  ------+---------+---------+----------  中断控制器通信(ICC)总线
                  |
              +-------+      
              |  I/O  |
              |  APIC |   外部APIC          
              +-------+  
    
    相对于本地APIC，外部APIC起路由器的作用。
    静态分发：中断传给一个特定的cpu或一组cpu，或所有cpu
    动态分发：每个本地APIC都有一个优先级寄存器（TPR）。TPR计算当前运行进程的优先级。仲裁分配负荷。


> 中断描述符表(IDT)
    是一个系统表，它与每一个中断或异常向量相联系。每一个向量在表中有相应的中断或异常处理程序的入口地址
    每个向量由8字节组成。一共256*8字节存放IDT
    
// 参考资料
    https://www.cnblogs.com/wang_yb/archive/2013/04/19/3030345.html

```

### 中断处理
```
(1) 注册中断
    #include <linux/interrupt.h>
    int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void *dev)
    //注意：此函可能会睡眠，不能再中断上下文或其他不允许阻塞的代码中调用该函数
    > irg
        表示要分配的中断号，有些是预先设定（键盘鼠标），可以通过探测获取，可以通过编程动态确定
    > handler
        实际的中断处理程序
        typedef irqreturn_t (*irq_handler_t)(int, void*)
    > flags
        表示中断处理标志
        IRQF_DISABLED: 设置后表示禁止其他中断，很野蛮地行为
        TRQF_SAMPLE_RANDOM: 表明这个设备对内核熵池有贡献
        IRQF_TIMER: 表明为系统定时器中断处理而准备
        IRQF_SHARED: 可以使多个中断程序共享一个中断线
    > name
        表示中断相关设备的ASCII文本，比如pc键盘中断对应的'keyboard',以便与用户进行通信，这些会被/proc/irq和/proc/interrupts文件使用
    > dev
        用于共享中断线，多个中断程序共享一个中断线时(共用一个中断号)，依靠dev来区别各个中断程序
    > 返回值
        执行成功：0 执行失败：非0

(2) 释放中断
    void free_irq(unsigned int irq, void* dev)
    > 如果不是共享中断线，则直接删除irq对应的中断线。
    > 如果是共享中断线，则判断此中断处理程序是否中断线上的最后一个中断处理程序，
        > 是最后一个中断处理程序 -> 删除中断线和中断处理程序
        > 不是最后一个中断处理程序 -> 删除中断处理程序

(3) 中断处理程序
    static irqreturn_t handler(int irq, void* dev) 
    > irq
        中断处理程序(即request_irq()中handler)关联的中断号
    > dev
        与request_irq()中的dev一样，表示一个设备的结构体    
    > irqreturn_t
        执行成功：IRQ_HANDLED  执行失败：IRQ_NONE

(4) 共享中断处理程序
    > flags必须是IRQF_SHARED
    > 当收到中断信号时，会依次调用注册的函数
    > 中断处理程序区分他的设备是否产生了中断，需要硬件和软件的支持
    > 注册条件：中断线当前未被注册或者被注册的中断都是IRQF_SHARED
```

### 中断API
```
local_irq_disable()	禁止本地中断传递
local_irq_enable()	激活本地中断传递
local_irq_save()	保存本地中断传递的当前状态，然后禁止本地中断传递
local_irq_restore()	恢复本地中断传递到给定的状态
disable_irq()	禁止给定中断线，并确保该函数返回之前在该中断线上没有处理程序在运行
disable_irq_nosync()	禁止给定中断线
enable_irq()	激活给定中断线
irqs_disabled()	如果本地中断传递被禁止，则返回非0；否则返回0
in_interrupt()	如果在中断上下文中，则返回非0；如果在进程上下文中，则返回0
in_irq()	如果当前正在执行中断处理程序，则返回非0；否则返回0
```

### 中断机制
```
https://www.cnblogs.com/wang_yb/archive/2013/04/19/3030345.html

设备产生中断，并通过中断线将中断信号送往中断控制器，如果中断没有被屏蔽则会到达CPU的INTR引脚，CPU立即停止当前工作，根据获得中断向量号从IDT中找出门描述符，并执行相关中断程序。

//处理流程
    > do_IRQ 与体系结构有关，对所接收的中断进行应答
    > handle_IRQ_event 调用中断线上所有中断处理
    > ret_from_intr 恢复寄存器，将内核恢复到中断前的状态

    硬件处理    中断控制器 -> 处理器 -> 处理器中断内核
                                            |
                    +-----------------------+
                    ↓                                是
    内核处理    do_IRQ() -> 该线上是否有中断处理程序 -----> handle_IRQ_event()
                                       |                        ↓
                                       | 否            运行该线的所有中断处理程序
                                       |                        |
                                       +-----------+------------+
                                                   ↓
                                             ret_from_intr()
                                                   ↓
                                          返回内核之前运行的代码          

```


