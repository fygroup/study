### 定时器的原理
```
定时器的实现依赖的是CPU时钟中断，时钟中断的精度就决定定时器精度的极限

一个时钟中断源如何实现多个定时器呢？
    对于内核，简单来说就是用特定的数据结构管理众多的定时器，在时钟中断处理中判断哪些定时器超时，然后执行超时处理动作
    而用户空间程序不直接感知CPU时钟中断，通过感知内核的信号、IO事件、调度，间接依赖时钟中断

用软件来实现动态定时器常用数据结构有：时间轮、最小堆和红黑树。一些知名的实现：
    Hierarchy 时间轮算法：Linux内核
    红黑树最小堆算法：Asio C++ Library或nginx
```

### Linux上的定时函数
```
https://zhuanlan.zhihu.com/p/372551679

Function                Type                Precision   Remark
sleep(3)                unsigned int        second	
usleep(3)	            useconds_t	        microsecond	
nanosleep(2)	        struct timespec	    nanosecond	
clock_nanosleep(2)	    struct timespec	    nanosecond	<1>
alarm(2)	            unsigned int	    second	    SIGALRM
setitimer(2)	        struct itimerval	microsecond	SIGALRM
timer_settime(2)	    struct itimerspec	nanosecond	notify method : struct sigevent
Timerfd API	            File descriptor	    nanosecond	From linux kernel 2.6.25

<1> It differs in allowing the caller to select the clock against which the sleep interval is to be measured, and in allowingthe sleep interval to be specified as either an absolute or a relative value

```
